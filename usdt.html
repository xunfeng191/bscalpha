<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BSC USDT ç»Ÿè®¡åˆ†æå·¥å…·</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        .trade-card {
            transition: all 0.2s ease;
            margin-bottom: 15px;
        }
        .trade-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .buy-card {
            border-left: 4px solid #28a745;
        }
        .sell-card {
            border-left: 4px solid #dc3545;
        }
        .stats-box {
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin: 20px auto;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(#0000 10%, #3498db);
            -webkit-mask: radial-gradient(farthest-side, #0000 calc(100% - 8px), #000 0);
            mask: radial-gradient(farthest-side, #0000 calc(100% - 8px), #000 0);
            animation: spin 1s infinite linear;
        }
        .loading-text {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        .loading-progress {
            margin-top: 10px;
            width: 250px;
            height: 6px;
            background-color: #eee;
            border-radius: 3px;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background-color: #3498db;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        @keyframes spin {
            to { transform: rotate(1turn); }
        }
        .progress-info {
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 4px solid #3498db;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 14px;
            color: #333;
            border-radius: 4px;
        }
        .hidden {
            display: none;
        }
        .wallet-input {
            margin-bottom: 10px;
        }
        .wallet-input .input-group-append {
            cursor: pointer;
        }
        #addWalletBtn {
            margin-bottom: 10px;
        }
        .remove-wallet {
            cursor: pointer;
            color: #dc3545;
        }
        .wallet-addresses {
            min-height: 100px;
            font-family: monospace;
        }
        .usdt-in { color: #28a745; }
        .usdt-out { color: #dc3545; }
        .ellipsis { max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; vertical-align: bottom; }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4 text-center">BSC USDT ç»Ÿè®¡åˆ†æå·¥å…·</h1>
        
        <div class="card mb-4">
            <div class="card-body">
                <form id="analyzeForm">
                    <div class="row g-3">
                        <div class="col-md-8">
                            <label class="form-label">BSC é’±åŒ…åœ°å€ï¼ˆæ”¯æŒå¸¦åç§°ï¼Œæ¯è¡Œä¸€ä¸ªï¼‰</label>
                            <textarea class="form-control wallet-addresses" rows="5" placeholder="è¾“å…¥æ ¼å¼ï¼š
åç§° 0xå¼€å¤´çš„BSCé’±åŒ…åœ°å€
ä¾‹å¦‚ï¼š
å¿µå®‰1 0xXX
å¿µå®‰2 0xXX" required></textarea>
                            <small class="text-muted">æ¯è¡Œä¸€ä¸ªåœ°å€ï¼Œå¯ä»¥åœ¨åœ°å€å‰åŠ åç§°ï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼‰</small>
                        </div>
                        <div class="col-md-4">
                            <label for="date" class="form-label">ç»Ÿè®¡æ—¥æœŸ</label>
                            <input type="date" class="form-control" id="date">
                            <small class="text-muted">ä¸å¡«é»˜è®¤ç»Ÿè®¡ä»Šå¤©8:00åˆ°æ˜å¤©8:00çš„æ•°æ®</small>
                        </div>
                        <div class="col-md-4" style="display: none;">
                            <label for="txLimit" class="form-label">äº¤æ˜“å¤„ç†é™åˆ¶</label>
                            <select class="form-control" id="txLimit">
                                <option value="50">ä»…å¤„ç†æœ€è¿‘50ç¬”äº¤æ˜“</option>
                                <option value="100">ä»…å¤„ç†æœ€è¿‘100ç¬”äº¤æ˜“</option>
                                <option value="200">ä»…å¤„ç†æœ€è¿‘200ç¬”äº¤æ˜“</option>
                                <option value="all" selected>å¤„ç†æ‰€æœ‰äº¤æ˜“</option>
                            </select>
                            <small class="text-muted">é™åˆ¶å¤„ç†çš„äº¤æ˜“æ•°é‡å¯ä»¥æé«˜æ€§èƒ½</small>
                        </div>
                    </div>
                    
                    <!-- æ·»åŠ ç»Ÿè®¡è¯´æ˜ -->
                    <div class="alert alert-info mt-3" role="alert">
                        <h6 class="alert-heading">ğŸ“Š ç»Ÿè®¡è¯´æ˜</h6>
                        <ul class="mb-0">
                            <li><strong>ç»Ÿè®¡æ—¶é—´ï¼š</strong>ä¸å¡«é»˜è®¤ç»Ÿè®¡ä»Šå¤©8:00åˆ°æ˜å¤©8:00çš„æ•°æ®</li>
                            <li><strong>å¤„ç†èŒƒå›´ï¼š</strong>åªå¤„ç†USDT/USDCå¯¹çš„äº¤æ˜“æƒ…å†µï¼ˆå¦‚ USDT/ZKJã€USDC/ZKJç­‰äº¤æ˜“å¯¹ï¼‰</li>
                            <li><strong>ä¸è®¡å…¥ç»Ÿè®¡ï¼š</strong>æ™®é€šUSDT/USDCè½¬è´¦ã€æµå…¥ã€æµå‡ºä¸è®¡å…¥ä¹°å–ç»Ÿè®¡</li>
                        </ul>
                    </div>
                    
                    <div class="row mt-3">
                        <div class="col-12">
                            <button type="submit" class="btn btn-primary">
                                <span class="normal-text">åˆ†æ</span>
                                <span class="spinner-border spinner-border-sm hidden" id="submitSpinner" role="status"></span>
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <div id="errorMessage" class="alert alert-danger hidden" role="alert"></div>
        <div id="loader" class="loader hidden">
            <div class="loading-spinner"></div>
            <div class="loading-text">æ­£åœ¨åˆ†æäº¤æ˜“æ•°æ®...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" style="width: 0%"></div>
            </div>
            <div id="loading-detail" class="loading-text"></div>
        </div>

        <div id="resultContainer" class="hidden">
            <div class="card mb-4">
                <div class="card-header">
                    <h4>åˆ†æç»“æœ</h4>
                    <p class="text-muted mb-0" id="timeRangeInfo"></p>
                </div>
            </div>

            <!-- è´¦æˆ·åˆ†æç»“æœå®¹å™¨ -->
            <div id="accountsContainer"></div>

            <div id="noTradesMessage" class="alert alert-info hidden">åœ¨æŒ‡å®šæ—¶é—´èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°USDTä¹°å–</div>
        </div>
        
        <div class="mt-4 text-center">
            <p class="text-muted mb-2">
                ä½œè€…: ä¸œä¸œ 
                <a href="https://x.com/lumaodaren" target="_blank" class="text-decoration-none">
                    <i class="bi bi-twitter-x"></i> @lumaodaren
                </a>
            </p>
            <p class="text-muted">
                <a href="https://github.com/sincitysh/bscalpha" target="_blank" class="text-decoration-none">
                    <i class="bi bi-github"></i> æŸ¥çœ‹æºç 
                </a>
                |
                æœ¬å·¥å…·åœ¨GitHub Pagesä¸Šè¿è¡Œï¼Œæ— éœ€æœåŠ¡å™¨
            </p>
        </div>
    </div>

    <!-- æ·»åŠ Web3.jsåº“ -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    
    <!-- æ·»åŠ Bootstrapçš„JavaScriptä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // 1. ä¿®å¤æ—¶é—´æˆ³é—®é¢˜ - å½»åº•é‡å†™formatTimeå‡½æ•°
        function formatTime(ts) {
            // ç¡®ä¿tsæ˜¯æ•°å­—
            let timestamp = typeof ts === 'string' ? parseInt(ts) : ts;
            
            // åˆ›å»ºæ—¥æœŸå¯¹è±¡
            const date = new Date(timestamp * 1000);
            
            // æ ¼å¼åŒ–ä¸ºæœ¬åœ°æ—¶é—´å­—ç¬¦ä¸²ï¼ˆä¸åšå¹´ä»½ä¿®æ”¹ï¼‰
            return date.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }).replace(/\//g, '-');
        }

        function formatDateTime(date) {
            if (!(date instanceof Date) || isNaN(date.getTime())) {
                console.warn('æ— æ•ˆçš„æ—¥æœŸå¯¹è±¡:', date);
                return new Date().toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }).replace(/\//g, '-');
            }
            
            return date.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            }).replace(/\//g, '-');
        }

        const USDT_CONTRACT = '0x55d398326f99059fF775485246999027B3197955';
        
        // æ·»åŠ USDCåˆçº¦åœ°å€
        const USDC_CONTRACT = '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d';
        
        // ç¨³å®šå¸é…ç½®
        const STABLECOINS = {
            'USDT': {
                contract: USDT_CONTRACT.toLowerCase(),
                symbol: 'USDT',
                name: 'Tether USD',
                decimals: 18
            },
            'USDC': {
                contract: USDC_CONTRACT.toLowerCase(), 
                symbol: 'USDC',
                name: 'USD Coin',
                decimals: 18
            }
        };
        
        // ç¨³å®šå¸åˆçº¦åœ°å€åˆ—è¡¨
        const STABLECOIN_CONTRACTS = [USDT_CONTRACT.toLowerCase(), USDC_CONTRACT.toLowerCase()];

        const BSCSCAN_API_KEYS = [
            'GFCARE1KCXRXZUTWYCRV9K65Q1V8BXZU3K',
            'AMQYJJTKB7H8GGSDY3K42G989M6S7INCFG',
            'R613WACX85IZPMASA6K8EAXTT85JQQG6J8',
            'W8U2D8MVYQCVN2TR1FU5IJB186436997CF',
            'T8RZ9IAIMPPDE665TSIP14Y3RYAWK23W3I'
        ];

        function getRandomApiKey() {
            const randomIndex = Math.floor(Math.random() * BSCSCAN_API_KEYS.length);
            return BSCSCAN_API_KEYS[randomIndex];
        }

        const DEX_ROUTER_LIST = [
            '0x10ed43c718714eb63d5aa57b78b54704e256024e', // PancakeSwap v2
            '0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F', // PancakeSwap v1
            '0x3a6d8ca21d1cf76f653a67577fa0d27453350dd8', // BiSwap
            '0xcDe540d7eAFE93aC5fE6233Bee57E1270D3E330F', // BakerySwap
            '0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607', // ApeSwap
            '0x7a6e4e3cc2ac9924605dc68f5d95e75e5f629b31', // Mdex Router
            '0x1b96b92314c44b159149f7e0303511fb2fc4774f', // PancakeSwap v2 (è€è·¯ç”±)
            '0x1111111254eeb25477b68fb85ed929f73a960582', // 1inch v4 Router
            '0x11111112542d85b3ef69ae05771c2dccff4faa26', // 1inch v3 Router
            '0x111111125434b319222cdbf8c261674adb56f3ae', // 1inch v2 Router
            '0x72c30ba151f8a9d9372e887a41e577d8b49dda6c', // LiquidMesh Router (æ–°å¢)
        ];

        // å®šä¹‰è·¯ç”±åœ°å€
        const routerAddresses = {
            'PancakeSwap': '0x10ED43C718714eb63d5aA57B78B54704E256024E'.toLowerCase(),
            'BiSwap': '0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8'.toLowerCase(),
            'BaseSwap': '0x13f4EA83D0bd40E75C8222255bc855a974568Dd4'.toLowerCase(),
            'BaseSwapRouter': '0xb300000b72deaeb607a12d5f54773d1c19c7028d'.toLowerCase(), // ç¡®ä¿è¿™ä¸ªåœ°å€æ­£ç¡®æ·»åŠ 
            'LiquidMesh': '0x72c30ba151f8a9d9372e887a41e577d8b49dda6c'.toLowerCase(), // æ–°å¢
            // ... å…¶ä»–åœ°å€ ...
        };

        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('analyzeForm');
            const loader = document.getElementById('loader');
            const errorMessage = document.getElementById('errorMessage');
            const resultContainer = document.getElementById('resultContainer');
            const submitSpinner = document.getElementById('submitSpinner');
            const noTradesMessage = document.getElementById('noTradesMessage');
            
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // è·å–å¹¶å¤„ç†é’±åŒ…åœ°å€
                const addressesText = form.querySelector('.wallet-addresses').value;
                const addressEntries = addressesText.split('\n')
                    .map(line => {
                        const parts = line.trim().split(/[\s\t]+/);
                        if (parts.length >= 2) {
                            return {
                                name: parts[0],
                                address: parts[parts.length - 1].trim()
                            };
                        } else if (parts.length === 1 && parts[0]) {
                            return {
                                name: 'æœªå‘½å',
                                address: parts[0].trim()
                            };
                        }
                        return null;
                    })
                    .filter(Boolean);
                
                // éªŒè¯åœ°å€
                for (const entry of addressEntries) {
                    if (!isValidAddress(entry.address)) {
                        errorMessage.textContent = `æ— æ•ˆçš„é’±åŒ…åœ°å€æ ¼å¼: ${entry.address}`;
                        errorMessage.classList.remove('hidden');
                        return;
                    }
                }

                if (addressEntries.length === 0) {
                    errorMessage.textContent = 'è¯·è‡³å°‘è¾“å…¥ä¸€ä¸ªé’±åŒ…åœ°å€';
                    errorMessage.classList.remove('hidden');
                    return;
                }
                
                const date = document.getElementById('date').value;
                
                console.log('å¼€å§‹åˆ†æï¼Œè¾“å…¥çš„é’±åŒ…åœ°å€ï¼š', addressesText);
                console.log('è§£æåçš„åœ°å€å¯¹è±¡ï¼š', addressEntries);
                console.log('é€‰æ‹©çš„æ—¥æœŸï¼š', date);
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                toggleLoading(true);
                errorMessage.classList.add('hidden');
                errorMessage.textContent = '';
                resultContainer.classList.add('hidden');
                
                try {
                    // è·å–æ—¶é—´èŒƒå›´
                    const timeRange = getTimeRange(date);
                    console.log('ğŸ“… ç»Ÿè®¡æ—¶é—´èŒƒå›´:', timeRange);
                    
                    // å¹¶è¡Œè·å–BNBä»·æ ¼å’ŒUSDTä»·æ ¼
                    const [bnbPrice, usdtPrice] = await Promise.all([
                        getBNBPrice(),
                        getUSDTPrice()
                    ]);
                    
                    console.log(`ğŸ’° å½“å‰ä»·æ ¼: BNB=${bnbPrice} USDT, USDT=${usdtPrice} USD`);
                    
                    // ğŸš€ ä½¿ç”¨æ–°çš„ApiUtilsæ‰¹é‡å¤„ç† - å‚è€ƒalpha.dogæ¨¡å¼
                    console.log(`ğŸš€ ä½¿ç”¨é«˜æ•ˆæ‰¹é‡å¤„ç†æ¨¡å¼å¤„ç† ${addressEntries.length} ä¸ªåœ°å€...`);
                    
                    // è¿›åº¦å›è°ƒå‡½æ•°
                    const progressCallback = (completed, total, currentName, error = null) => {
                        const progress = Math.round((completed / total) * 100);
                        document.getElementById('loading-detail').textContent = 
                            error ? `å¤„ç† ${currentName}: å¤±è´¥ (${error})` : `å¤„ç† ${currentName}: å®Œæˆ`;
                        document.querySelector('.loading-progress-bar').style.width = `${progress}%`;
                    };
                    
                    // æ‰¹é‡è·å–æ‰€æœ‰åœ°å€çš„äº¤æ˜“æ•°æ®
                    const addressResults = await USDTApiUtils.fetchMultipleAddressesData(
                        addressEntries, 
                        timeRange, 
                        progressCallback
                    );
                    
                    // å¤„ç†ç»“æœï¼Œåˆ†æUSDTäº¤æ˜“
                    const allAnalysis = [];
                    const errors = [];
                    
                    console.log(`ğŸ” å¼€å§‹åˆ†æ ${addressResults.length} ä¸ªåœ°å€çš„äº¤æ˜“æ•°æ®...`);
                    
                    for (const result of addressResults) {
                        if (result.success) {
                            try {
                                console.log(`ğŸ“Š åˆ†æ ${result.entry.name} çš„äº¤æ˜“...`);
                                
                                // è·å–USDTä½™é¢
                                const balance = await getUSDTBalance(result.entry.address);
                                
                                // ä½¿ç”¨è¶…å¿«åˆ†æå‡½æ•°
                                const analysis = await analyzeFast(
                                    result.entry, 
                                    result.data, 
                                    timeRange, 
                                    usdtPrice, 
                                    bnbPrice, 
                                    balance
                                );
                                
                                allAnalysis.push(analysis);
                                console.log(`âœ… ${result.entry.name}: è¶…å¿«åˆ†æå®Œæˆ - ä¹°å…¥:${analysis.totalBuyValue.toFixed(2)} å–å‡º:${analysis.totalSellValue.toFixed(2)} å‡€ç›ˆäº:${analysis.netProfitLoss.toFixed(2)}`);
                                
                            } catch (e) {
                                console.error(`âŒ åˆ†æ ${result.entry.name} å¤±è´¥:`, e);
                                errors.push(`${result.entry.name}: åˆ†æå¤±è´¥ - ${e.message}`);
                            }
                        } else {
                            errors.push(`${result.entry.name}: æ•°æ®è·å–å¤±è´¥ - ${result.error}`);
                        }
                    }
                    
                    console.log(`ğŸ¯ å¤„ç†å®Œæˆ: ${allAnalysis.length}æˆåŠŸ, ${errors.length}å¤±è´¥`);
                    
                    // å¦‚æœæœ‰é”™è¯¯ä½†ä»æœ‰ä¸€äº›æˆåŠŸçš„ç»“æœï¼Œæ˜¾ç¤ºè¯¦ç»†è­¦å‘Š
                    if (errors.length > 0) {
                        const warningDiv = document.createElement('div');
                        warningDiv.className = 'alert alert-warning';
                        
                        const successCount = allAnalysis.length;
                        const totalCount = addressEntries.length;
                        
                        warningDiv.innerHTML = `
                            <h5>âš ï¸ å¤„ç†ç»“æœ: ${successCount}/${totalCount} ä¸ªåœ°å€æˆåŠŸ</h5>
                            <div class="row">
                                <div class="col-md-6">
                                    <h6 class="text-success">âœ… æˆåŠŸå¤„ç†çš„åœ°å€:</h6>
                                    <ul class="mb-0">
                                        ${allAnalysis.map(analysis => `<li><strong>${analysis.name}</strong> - ${analysis.trades.length}æ¡äº¤æ˜“</li>`).join('')}
                                    </ul>
                                </div>
                                <div class="col-md-6">
                                    <h6 class="text-danger">âŒ å¤„ç†å¤±è´¥çš„åœ°å€:</h6>
                                    <ul class="mb-0">
                                        ${errors.map(err => `<li>${err}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                            <div class="mt-3">
                                <small class="text-muted">
                                    <i class="bi bi-info-circle"></i> 
                                    å¤±è´¥åŸå› å¯èƒ½åŒ…æ‹¬ï¼šAPIé™åˆ¶ã€ç½‘ç»œè¶…æ—¶ã€åœ°å€æ— äº¤æ˜“è®°å½•ç­‰ã€‚æ‚¨å¯ä»¥ç¨åé‡è¯•å¤±è´¥çš„åœ°å€ã€‚
                                </small>
                            </div>
                        `;
                        resultContainer.insertBefore(warningDiv, resultContainer.firstChild);
                    }
                    
                    // å¦‚æœå®Œå…¨æ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
                    if (allAnalysis.length === 0) {
                        if (errors.length > 0) {
                            const errorDiv = document.createElement('div');
                            errorDiv.className = 'alert alert-danger';
                            errorDiv.innerHTML = `
                                <h5>âŒ æ‰€æœ‰åœ°å€å¤„ç†å¤±è´¥</h5>
                                <p><strong>å¤±è´¥çš„åœ°å€å’ŒåŸå› ï¼š</strong></p>
                                <ul>
                                    ${errors.map(err => `<li>${err}</li>`).join('')}
                                </ul>
                                <hr>
                                <h6>å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼š</h6>
                                <ul class="mb-0">
                                    <li>æ£€æŸ¥é’±åŒ…åœ°å€æ ¼å¼æ˜¯å¦æ­£ç¡®</li>
                                    <li>ç¡®è®¤åœ°å€åœ¨æŒ‡å®šæ—¶é—´èŒƒå›´å†…æœ‰äº¤æ˜“</li>
                                    <li>ç¨ç­‰å‡ åˆ†é’Ÿåé‡è¯•ï¼ˆå¯èƒ½é‡åˆ°APIé™åˆ¶ï¼‰</li>
                                    <li>å°è¯•å‡å°‘åŒæ—¶æŸ¥è¯¢çš„åœ°å€æ•°é‡</li>
                                </ul>
                            `;
                            resultContainer.appendChild(errorDiv);
                            resultContainer.classList.remove('hidden');
                        } else {
                            resultContainer.classList.remove('hidden');
                            noTradesMessage.classList.remove('hidden');
                            document.getElementById('timeRangeInfo').textContent = `ç»Ÿè®¡æ—¶é—´: ${formatDateTime(timeRange.startDate)} è‡³ ${formatDateTime(timeRange.endDate)}`;
                        }
                        return;
                    }
                    
                    // æ¸²æŸ“ç»“æœ
                    await renderResults({
                        success: true,
                        addressEntries: allAnalysis.map(analysis => ({
                            name: analysis.name,
                            address: analysis.address
                        })),
                        allAnalysis
                    });
                    
                    resultContainer.classList.remove('hidden');
                    console.log(`ğŸ‰ å…¨éƒ¨å®Œæˆ! æ€»å…±åˆ†æäº† ${allAnalysis.length} ä¸ªåœ°å€`);
                } catch (error) {
                    console.error('åˆ†æå¤±è´¥:', error);
                    errorMessage.textContent = error.message || 'å¤„ç†è¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯';
                    errorMessage.classList.remove('hidden');
                } finally {
                    toggleLoading(false);
                }
            });
            
            function toggleLoading(isLoading) {
                if (isLoading) {
                    loader.classList.remove('hidden');
                    submitSpinner.classList.remove('hidden');
                    document.querySelector('.normal-text').classList.add('hidden');
                    document.querySelector('.loading-progress-bar').style.width = '0%';
                    document.getElementById('loading-detail').textContent = 'å‡†å¤‡åˆ†æ...';
                } else {
                    loader.classList.add('hidden');
                    submitSpinner.classList.add('hidden');
                    document.querySelector('.normal-text').classList.remove('hidden');
                }
            }
            
            function isValidAddress(address) {
                return /^0x[a-fA-F0-9]{40}$/.test(address);
            }
            
            // è·å–USDTä»·æ ¼ï¼ˆUSDTå¯¹USDTæ°¸è¿œæ˜¯1ï¼‰
            async function getUSDTPrice() {
                return 1;
            }
            
            // ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è¯·æ±‚
            const receiptCache = new Map();
            const txDetailCache = new Map();
            const balanceCache = new Map();
            
            // æ·»åŠ å»¶è¿Ÿå‡½æ•°
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            // ä¼˜åŒ–getTxReceiptå‡½æ•° - æ·»åŠ ç¼“å­˜å’Œå‡å°‘é‡è¯•
            async function getTxReceipt(txHash) {
                if (receiptCache.has(txHash)) return receiptCache.get(txHash);
                
                try {
                    const url = `https://api.bscscan.com/api?module=proxy&action=eth_getTransactionReceipt&txhash=${txHash}&apikey=${getRandomApiKey()}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    
                    if (data.result) {
                        receiptCache.set(txHash, data.result);
                        return data.result;
                    }
                    return null;
                } catch (e) {
                    console.warn(`è·å–äº¤æ˜“æ”¶æ®å¤±è´¥: ${txHash.slice(0, 10)}...`);
                    return null;
                }
            }
            
            // ä¼˜åŒ–getTxDetailå‡½æ•° - æ·»åŠ ç¼“å­˜å’Œå‡å°‘é‡è¯•
            async function getTxDetail(txHash) {
                if (txDetailCache.has(txHash)) return txDetailCache.get(txHash);
                
                try {
                    const url = `https://api.bscscan.com/api?module=proxy&action=eth_getTransactionByHash&txhash=${txHash}&apikey=${getRandomApiKey()}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    
                    if (data.result) {
                        txDetailCache.set(txHash, data.result);
                        return data.result;
                    }
                    return null;
                } catch (e) {
                    console.warn(`è·å–äº¤æ˜“è¯¦æƒ…å¤±è´¥: ${txHash.slice(0, 10)}...`);
                    return null;
                }
            }
            
            // ä¼˜åŒ–getUSDTBalanceå‡½æ•° - æ·»åŠ ç¼“å­˜
            async function getUSDTBalance(address) {
                if (balanceCache.has(address)) {
                    return balanceCache.get(address);
                }
                
                try {
                    const url = `https://api.bscscan.com/api?module=account&action=tokenbalance&contractaddress=${USDT_CONTRACT}&address=${address}&tag=latest&apikey=${getRandomApiKey()}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    const balance = parseFloat(data.result) / 1e18;
                    balanceCache.set(address, balance);
                    return balance;
                } catch (e) {
                    console.warn(`è·å–USDTä½™é¢å¤±è´¥: ${address}`);
                    return 0;
                }
            }
            
            // è·å–USDCä½™é¢
            async function getUSDCBalance(address) {
                const cacheKey = `${address}_USDC`;
                if (balanceCache.has(cacheKey)) {
                    return balanceCache.get(cacheKey);
                }
                
                try {
                    const url = `https://api.bscscan.com/api?module=account&action=tokenbalance&contractaddress=${USDC_CONTRACT}&address=${address}&tag=latest&apikey=${getRandomApiKey()}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    const balance = parseFloat(data.result) / 1e18;
                    balanceCache.set(cacheKey, balance);
                    return balance;
                } catch (e) {
                    console.warn(`è·å–USDCä½™é¢å¤±è´¥: ${address}`);
                    return 0;
                }
            }
            
            // è·å–æ‰€æœ‰ç¨³å®šå¸ä½™é¢
            async function getAllStablecoinBalances(address) {
                try {
                    const [usdtBalance, usdcBalance] = await Promise.all([
                        getUSDTBalance(address),
                        getUSDCBalance(address)
                    ]);
                    
                    return {
                        USDT: usdtBalance,
                        USDC: usdcBalance,
                        total: usdtBalance + usdcBalance
                    };
                } catch (e) {
                    console.warn(`è·å–ç¨³å®šå¸ä½™é¢å¤±è´¥: ${address}`);
                    return {
                        USDT: 0,
                        USDC: 0,
                        total: 0
                    };
                }
            }
            
            // è·å–åœ°å€äº¤æ˜“
            async function getTxList(address, timeRange) {
                const url = `https://api.bscscan.com/api?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&starttime=${timeRange.start}&endtime=${timeRange.end}&sort=asc&apikey=${getRandomApiKey()}`;
                const res = await fetch(url);
                const data = await res.json();
                if (!Array.isArray(data.result)) {
                    console.error('BscScanè¿”å›å¼‚å¸¸:', data);
                    return [];
                }
                return data.result;
            }
            
            // ä¼˜åŒ–åçš„getUSDTTransferså‡½æ•° - ä¿®å¤åŒºå—èŒƒå›´é—®é¢˜
            async function getUSDTTransfers(address, timeRange, txLimit) {
                console.log(`ğŸš€ å¼€å§‹è·å– ${address.slice(0, 8)}...${address.slice(-6)} çš„äº¤æ˜“æ•°æ®`);
                
                try {
                    // åŠ¨æ€è®¡ç®—åŒºå—èŒƒå›´ï¼Œç¡®ä¿è¦†ç›–æŒ‡å®šæ—¶é—´
                    let startBlock, endBlock;
                    
                    try {
                        // å°è¯•åŠ¨æ€è·å–åŒºå—å·
                        console.log(`ğŸ” è·å–æ—¶é—´ ${new Date(timeRange.start*1000).toLocaleString()} å¯¹åº”çš„åŒºå—å·...`);
                        startBlock = await getBlockByTimestamp(timeRange.start, 'before');
                        
                        console.log(`ğŸ” è·å–æ—¶é—´ ${new Date(timeRange.end*1000).toLocaleString()} å¯¹åº”çš„åŒºå—å·...`);
                        endBlock = await getBlockByTimestamp(timeRange.end, 'after');
                        
                        console.log(`ğŸ“¦ ${address.slice(0, 8)}... åŠ¨æ€åŒºå—èŒƒå›´: ${startBlock} - ${endBlock}`);
                    } catch (e) {
                        // å¦‚æœåŠ¨æ€è·å–å¤±è´¥ï¼Œä½¿ç”¨æ›´å¤§çš„å›ºå®šèŒƒå›´
                        console.warn(`âš ï¸ åŠ¨æ€è·å–åŒºå—å·å¤±è´¥ï¼Œä½¿ç”¨æ‰©å¤§çš„å›ºå®šèŒƒå›´:`, e.message);
                        const currentBlock = 50200000; // åŸºå‡†åŒºå—
                        startBlock = Math.max(0, currentBlock - 200000); // æ‰©å¤§åˆ°20ä¸‡ä¸ªåŒºå—
                        endBlock = currentBlock + 50000; // å‘åæ‰©å±•5ä¸‡ä¸ªåŒºå—
                        
                        console.log(`ğŸ“¦ ${address.slice(0, 8)}... æ‰©å¤§å›ºå®šåŒºå—èŒƒå›´: ${startBlock} - ${endBlock}`);
                    }
                    
                    // ä¼˜åŒ–çš„fetchå‡½æ•°ï¼Œå¢åŠ æ›´é•¿çš„å»¶è¿Ÿå’Œæ›´å¥½çš„é”™è¯¯å¤„ç†
                    const fetchData = async (url, description) => {
                        try {
                            console.log(`ğŸ”„ ${address.slice(0, 8)}... ${description}...`);
                            
                            // å¢åŠ å»¶è¿Ÿé¿å…APIé™åˆ¶
                            await sleep(1000); // 1ç§’å»¶è¿Ÿ
                            
                            const res = await fetch(url);
                            const data = await res.json();
                            
                            console.log(`ğŸ“¡ ${address.slice(0, 8)}... APIå“åº”:`, data.status, data.message);
                            
                            if (data.status === '1' && Array.isArray(data.result)) {
                                console.log(`âœ… ${address.slice(0, 8)}... ${description}: ${data.result.length}æ¡`);
                                
                                // æ£€æŸ¥æ—¶é—´èŒƒå›´
                                if (data.result.length > 0) {
                                    const times = data.result.map(tx => parseInt(tx.timeStamp));
                                    const minTime = Math.min(...times);
                                    const maxTime = Math.max(...times);
                                    console.log(`â° ${address.slice(0, 8)}... æ•°æ®æ—¶é—´èŒƒå›´: ${new Date(minTime*1000).toLocaleString()} - ${new Date(maxTime*1000).toLocaleString()}`);
                                    console.log(`ğŸ¯ ${address.slice(0, 8)}... ç›®æ ‡æ—¶é—´èŒƒå›´: ${new Date(timeRange.start*1000).toLocaleString()} - ${new Date(timeRange.end*1000).toLocaleString()}`);
                                }
                                
                                return data.result;
                            } else if (data.status === '0' && (data.message.includes('No transactions found') || data.message.includes('No records found'))) {
                                console.log(`â„¹ï¸ ${address.slice(0, 8)}... ${description}: æ— è®°å½•`);
                                return [];
                            } else {
                                console.warn(`âš ï¸ ${address.slice(0, 8)}... ${description}å¤±è´¥:`, data.message);
                                // å¦‚æœæ˜¯é™åˆ¶é”™è¯¯ï¼Œç­‰å¾…æ›´é•¿æ—¶é—´
                                if (data.message && data.message.includes('rate limit')) {
                                    console.log(`â³ APIé™åˆ¶ï¼Œç­‰å¾…5ç§’...`);
                                    await sleep(5000);
                                }
                                return [];
                            }
                        } catch (e) {
                            console.error(`âŒ ${address.slice(0, 8)}... ${description}å‡ºé”™:`, e.message);
                            return []; // å‡ºé”™æ—¶è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
                        }
                    };
                    
                    // ä¸²è¡Œè·å–ä»¥é¿å…APIé™åˆ¶ï¼ˆä¸å†å¹¶è¡Œï¼‰
                    const tokenTxUrl = `https://api.bscscan.com/api?module=account&action=tokentx&contractaddress=${USDT_CONTRACT}&address=${address}&startblock=${startBlock}&endblock=${endBlock}&sort=asc&apikey=${getRandomApiKey()}`;
                    const normalTxUrl = `https://api.bscscan.com/api?module=account&action=txlist&address=${address}&startblock=${startBlock}&endblock=${endBlock}&sort=asc&apikey=${getRandomApiKey()}`;
                    
                    console.log(`ğŸ”„ ${address.slice(0, 8)}... å¼€å§‹ä¸²è¡Œè·å–æ•°æ®...`);
                    
                    // å…ˆè·å–USDTè½¬è´¦
                    const tokenTxs = await fetchData(tokenTxUrl, "USDTè½¬è´¦");
                    
                    // ç­‰å¾…æ›´é•¿æ—¶é—´å†è·å–æ™®é€šäº¤æ˜“
                    console.log(`â³ ${address.slice(0, 8)}... ç­‰å¾…2ç§’åè·å–æ™®é€šäº¤æ˜“...`);
                    await sleep(2000);
                    
                    const normalTxs = await fetchData(normalTxUrl, "æ™®é€šäº¤æ˜“");
                    
                    // å¿«é€Ÿåˆå¹¶å’Œè¿‡æ»¤ - ä¸¥æ ¼æŒ‰æ—¶é—´èŒƒå›´è¿‡æ»¤
                    const hashSet = new Set();
                    const mergedTxs = [];
                    
                    // å¤„ç†USDTä»£å¸è½¬è´¦ - æ·»åŠ è¯¦ç»†çš„è¿‡æ»¤æ—¥å¿—
                    let filteredTokenTxs = 0;
                    let validTokenTxs = 0;
                    for (const tx of tokenTxs) {
                        const time = parseInt(tx.timeStamp);
                        if (time >= timeRange.start && time < timeRange.end) {
                            hashSet.add(tx.hash);
                            mergedTxs.push(tx);
                            validTokenTxs++;
                            console.log(`âœ… ${address.slice(0, 8)}... åŒ…å«USDTè½¬è´¦: ${tx.hash}, æ—¶é—´: ${new Date(time*1000).toLocaleString()}`);
                        } else {
                            filteredTokenTxs++;
                            console.log(`â° ${address.slice(0, 8)}... æ—¶é—´è¿‡æ»¤USDTè½¬è´¦: ${tx.hash}, æ—¶é—´: ${new Date(time*1000).toLocaleString()}, è¶…å‡ºèŒƒå›´`);
                        }
                    }
                    
                    console.log(`ğŸ“Š ${address.slice(0, 8)}... USDTè½¬è´¦ç»Ÿè®¡: æœ‰æ•ˆ${validTokenTxs}æ¡, è¿‡æ»¤${filteredTokenTxs}æ¡`);
                    
                    // å¤„ç†æ™®é€šäº¤æ˜“ - ä¹Ÿè¦ä¸¥æ ¼æŒ‰æ—¶é—´è¿‡æ»¤ï¼Œä½†æ·»åŠ è¯¦ç»†æ—¥å¿—
                    let relevantCount = 0;
                    let filteredNormalTxs = 0;
                    let validNormalTxs = 0;
                    
                    for (const tx of normalTxs) {
                        const time = parseInt(tx.timeStamp);
                        
                        if (time < timeRange.start || time >= timeRange.end) {
                            filteredNormalTxs++;
                            console.log(`â° ${address.slice(0, 8)}... æ—¶é—´è¿‡æ»¤æ™®é€šäº¤æ˜“: ${tx.hash}, æ—¶é—´: ${new Date(time*1000).toLocaleString()}, è¶…å‡ºèŒƒå›´`);
                            continue;
                        }
                        
                        validNormalTxs++;
                        
                        if (hashSet.has(tx.hash)) {
                            console.log(`ğŸ”„ ${address.slice(0, 8)}... è·³è¿‡é‡å¤äº¤æ˜“: ${tx.hash}`);
                            continue;
                        }
                        
                        // å¿«é€Ÿé¢„ç­›é€‰
                        if (!tx.input || tx.input === '0x') {
                            console.log(`ğŸ“ ${address.slice(0, 8)}... è·³è¿‡æ— inputäº¤æ˜“: ${tx.hash}`);
                            continue;
                        }
                        
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        
                        // åªå¤„ç†æ˜ç¡®çš„swapæ–¹æ³•æˆ–ç‰¹æ®Šæ–¹æ³•
                        const importantMethods = [
                            '0xa03de6a9', '0x7c025200', '0x84bd6d29', '0x12aa3caf', 
                            '0xe5e8894b', '0x7ff36ab5', '0x38ed1739', '0x18cbafe5',
                            '0xe19c2253', '0x0d46641a' // ç‰¹æ®Šæ–¹æ³•
                        ];
                        
                        const isDEXRouter = DEX_ROUTER_LIST.includes(tx.to?.toLowerCase());
                        const isUSDTContract = tx.to?.toLowerCase() === USDT_CONTRACT.toLowerCase();
                        const isImportantMethod = importantMethods.includes(methodId);
                        
                        console.log(`ğŸ” ${address.slice(0, 8)}... æ£€æŸ¥äº¤æ˜“ ${tx.hash}:`);
                        console.log(`   æ–¹æ³•ID: ${methodId}`);
                        console.log(`   ç›®æ ‡åœ°å€: ${tx.to}`);
                        console.log(`   æ˜¯DEXè·¯ç”±: ${isDEXRouter}`);
                        console.log(`   æ˜¯USDTåˆçº¦: ${isUSDTContract}`);
                        console.log(`   æ˜¯é‡è¦æ–¹æ³•: ${isImportantMethod}`);
                        
                        if (isDEXRouter || isUSDTContract || isImportantMethod) {
                            // ç›´æ¥æ·»åŠ ï¼Œä¸åšå¤æ‚çš„Receiptæ£€æŸ¥
                            tx.contractAddress = USDT_CONTRACT;
                            mergedTxs.push(tx);
                            hashSet.add(tx.hash);
                            relevantCount++;
                            console.log(`âœ… ${address.slice(0, 8)}... åŒ…å«ç›¸å…³äº¤æ˜“: ${tx.hash}, åŸå› : ${isDEXRouter ? 'DEXè·¯ç”±' : isUSDTContract ? 'USDTåˆçº¦' : 'é‡è¦æ–¹æ³•'}`);
                        } else {
                            console.log(`âŒ ${address.slice(0, 8)}... è·³è¿‡ä¸ç›¸å…³äº¤æ˜“: ${tx.hash}`);
                        }
                    }
                    
                    console.log(`ğŸ“Š ${address.slice(0, 8)}... æ™®é€šäº¤æ˜“ç»Ÿè®¡: æ—¶é—´èŒƒå›´å†…${validNormalTxs}æ¡, ç›¸å…³${relevantCount}æ¡, è¿‡æ»¤${filteredNormalTxs}æ¡`);
                    
                    if (filteredNormalTxs > 0) {
                        console.log(`ğŸ” ${address.slice(0, 8)}... æ—¶é—´è¿‡æ»¤: ç§»é™¤${filteredNormalTxs}æ¡è¶…å‡ºèŒƒå›´çš„æ™®é€šäº¤æ˜“`);
                    }
                    
                    console.log(`ï¿½ï¿½ ${address.slice(0, 8)}... å¿«é€Ÿç­›é€‰: æ·»åŠ ${relevantCount}æ¡å¯èƒ½ç›¸å…³çš„æ™®é€šäº¤æ˜“`);
                    console.log(`ï¿½ï¿½ ${address.slice(0, 8)}... æœ€ç»ˆè·å¾— ${mergedTxs.length} æ¡ç›¸å…³äº¤æ˜“`);
                    
                    return mergedTxs;
                } catch (error) {
                    console.error(`ğŸ’¥ ${address.slice(0, 8)}... å¤„ç†å¤±è´¥:`, error);
                    throw new Error(`è·å–${address.slice(0, 8)}...çš„äº¤æ˜“æ•°æ®å¤±è´¥: ${error.message}`);
                }
            }
            
            // æ‰¹é‡å¤„ç†ç›¸å…³äº¤æ˜“
            async function processRelevantTransactions(relevantTxs, mergedTxs, hashSet) {
                const batchSize = 5; // æ¯æ‰¹å¤„ç†5ä¸ªäº¤æ˜“
                
                for (let i = 0; i < relevantTxs.length; i += batchSize) {
                    const batch = relevantTxs.slice(i, i + batchSize);
                    console.log(`âš™ï¸ å¤„ç†äº¤æ˜“æ‰¹æ¬¡ ${Math.floor(i/batchSize) + 1}/${Math.ceil(relevantTxs.length/batchSize)} (${batch.length}æ¡)`);
                    
                    // å¹¶è¡Œå¤„ç†è¿™ä¸€æ‰¹äº¤æ˜“
                    const results = await Promise.allSettled(
                        batch.map(tx => processTransaction(tx))
                    );
                    
                    // æ·»åŠ æˆåŠŸå¤„ç†çš„äº¤æ˜“
                    for (let j = 0; j < results.length; j++) {
                        const result = results[j];
                        const tx = batch[j];
                        
                        if (result.status === 'fulfilled' && result.value) {
                            tx.contractAddress = USDT_CONTRACT;
                            mergedTxs.push(tx);
                            hashSet.add(tx.hash);
                            console.log(`âœ… æ·»åŠ äº¤æ˜“: ${tx.hash.slice(0, 10)}...`);
                        }
                    }
                    
                    // å°å»¶è¿Ÿé¿å…APIé™åˆ¶
                    if (i + batchSize < relevantTxs.length) {
                        await sleep(200); // å‡å°‘åˆ°200ms
                    }
                }
            }
            
            // å¤„ç†å•ä¸ªäº¤æ˜“
            async function processTransaction(tx) {
                try {
                    const methodId = tx.input?.slice(0, 10).toLowerCase();
                    
                    // ç‰¹æ®Šæ–¹æ³•IDç›´æ¥é€šè¿‡
                    if (methodId === '0xe19c2253' || methodId === '0x0d46641a') {
                        return true;
                    }
                    
                    // USDTåˆçº¦ç›´æ¥äº¤äº’
                    if (tx.to?.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                        return true;
                    }
                    
                    // æ£€æŸ¥swapäº¤æ˜“æ˜¯å¦æ¶‰åŠUSDT
                    const receipt = await getTxReceipt(tx.hash);
                    if (receipt?.logs) {
                        const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                        return receipt.logs.some(log => 
                            log.address.toLowerCase() === USDT_CONTRACT.toLowerCase() && 
                            log.topics[0] === ERC20_TRANSFER_TOPIC
                        );
                    }
                    
                    return false;
                } catch (error) {
                    console.warn(`âš ï¸ å¤„ç†äº¤æ˜“å¤±è´¥ ${tx.hash}: ${error.message}`);
                    return false;
                }
            }
            
            // ä¼˜åŒ–åŒºå—å·è·å–å‡½æ•° - æ”¹è¿›é”™è¯¯å¤„ç†
            const blockCache = new Map();
            async function getBlockByTimestamp(timestamp, closest = 'before') {
                const cacheKey = `${timestamp}_${closest}`;
                if (blockCache.has(cacheKey)) {
                    console.log(`ğŸ“¦ ä½¿ç”¨ç¼“å­˜çš„åŒºå—å·: ${blockCache.get(cacheKey)}`);
                    return blockCache.get(cacheKey);
                }
                
                let retries = 3;
                while (retries > 0) {
                    try {
                        console.log(`ğŸ” è·å–åŒºå—å· (å‰©ä½™é‡è¯•${retries}æ¬¡): ${new Date(timestamp*1000).toLocaleString()}`);
                        const url = `https://api.bscscan.com/api?module=block&action=getblocknobytime&timestamp=${timestamp}&closest=${closest}&apikey=${getRandomApiKey()}`;
                        const res = await fetch(url);
                        const data = await res.json();
                        
                        console.log(`ğŸ“¡ åŒºå—å·APIå“åº”:`, data.status, data.message);
                        
                        if (data.status === '1' && data.result) {
                            const blockNumber = parseInt(data.result);
                            if (blockNumber > 0) {
                                blockCache.set(cacheKey, blockNumber);
                                console.log(`âœ… ${new Date(timestamp*1000).toLocaleString()} â†’ åŒºå— ${blockNumber}`);
                                return blockNumber;
                            }
                        }
                        
                        console.warn(`âš ï¸ è·å–åŒºå—å·å¤±è´¥: ${data.message || 'æ— æ•ˆå“åº”'}`);
                        retries--;
                        if (retries > 0) {
                            console.log(`â³ ç­‰å¾…2ç§’åé‡è¯•...`);
                            await sleep(2000);
                        }
                    } catch (error) {
                        console.error(`âŒ è·å–åŒºå—å·å‡ºé”™: ${error.message}`);
                        retries--;
                        if (retries > 0) {
                            console.log(`â³ ç­‰å¾…2ç§’åé‡è¯•...`);
                            await sleep(2000);
                        }
                    }
                }
                
                // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼Œä½¿ç”¨åˆç†çš„é»˜è®¤å€¼
                console.warn(`âš ï¸ è·å–åŒºå—å·æœ€ç»ˆå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
                const defaultBlock = closest === 'before' ? Math.max(0, 50000000) : 50300000;
                blockCache.set(cacheKey, defaultBlock);
                return defaultBlock;
            }
            
            // ä¿®æ”¹analyzeTransactionså‡½æ•°ï¼Œå‡å°‘APIè°ƒç”¨
            async function analyzeTransactions(addressInfo, transfers, timeRange, usdtPrice, bnbPrice, usdtBalance) {
                console.log(`ğŸ” å¼€å§‹åˆ†æ ${addressInfo.name} çš„ ${transfers.length} æ¡äº¤æ˜“`);
                
                // éªŒè¯æ‰€æœ‰äº¤æ˜“çš„æ—¶é—´èŒƒå›´
                const invalidTimeTransfers = transfers.filter(tx => {
                    const time = parseInt(tx.timeStamp);
                    return time < timeRange.start || time >= timeRange.end;
                });
                
                if (invalidTimeTransfers.length > 0) {
                    console.warn(`âš ï¸ ${addressInfo.name}: å‘ç°${invalidTimeTransfers.length}æ¡è¶…å‡ºæ—¶é—´èŒƒå›´çš„äº¤æ˜“`);
                    invalidTimeTransfers.forEach(tx => {
                        const time = parseInt(tx.timeStamp);
                        console.log(`   - ${tx.hash}: ${new Date(time*1000).toLocaleString()} (åº”åœ¨ ${new Date(timeRange.start*1000).toLocaleString()} - ${new Date(timeRange.end*1000).toLocaleString()})`);
                    });
                }
                
                // è¿‡æ»¤å‡ºç›´æ¥ç›¸å…³ä¸”åœ¨æ—¶é—´èŒƒå›´å†…çš„äº¤æ˜“
                const address = addressInfo.address.toLowerCase();
                const relevantTransfers = transfers.filter(tx => {
                    const time = parseInt(tx.timeStamp);
                    const isInTimeRange = time >= timeRange.start && time < timeRange.end;
                    const isRelevant = tx.from?.toLowerCase() === address || tx.to?.toLowerCase() === address || tx.contractAddress?.toLowerCase() === USDT_CONTRACT.toLowerCase();
                    
                    if (!isInTimeRange) {
                        console.log(`â° æ—¶é—´è¿‡æ»¤: ${tx.hash} æ—¶é—´${new Date(time*1000).toLocaleString()} è¶…å‡ºèŒƒå›´`);
                    }
                    
                    return isInTimeRange && isRelevant;
                });
                
                console.log(`âœ… ${addressInfo.name}: æ—¶é—´å’Œç›¸å…³æ€§è¿‡æ»¤åå‰©ä½™ ${relevantTransfers.length} æ¡äº¤æ˜“`);
                
                // æ·»åŠ äº¤æ˜“è¯¦ç»†æ£€æŸ¥
                if (relevantTransfers.length > 0) {
                    console.log(`ğŸ” ${addressInfo.name} äº¤æ˜“è¯¦æƒ…æ£€æŸ¥:`);
                    relevantTransfers.forEach((tx, index) => {
                        const time = parseInt(tx.timeStamp);
                        console.log(`   ${index + 1}. ${tx.hash}:`);
                        console.log(`      æ—¶é—´: ${new Date(time*1000).toLocaleString()}`);
                        console.log(`      ä»: ${tx.from}`);
                        console.log(`      åˆ°: ${tx.to}`);
                        console.log(`      åˆçº¦: ${tx.contractAddress || 'æ— '}`);
                        console.log(`      é‡‘é¢: ${tx.value || '0'}`);
                        console.log(`      input: ${tx.input ? tx.input.slice(0, 20) + '...' : 'æ— '}`);
                    });
                }
                
                // æŒ‰äº¤æ˜“å“ˆå¸Œåˆ†ç»„
                const grouped = groupByHash(relevantTransfers);
                console.log(`ã€${addressInfo.name}ã€‘USDTè½¬è´¦åˆ†ç»„ï¼ˆæŒ‰hashï¼‰:`, grouped.map(g => g[0].hash));
                
                const trades = [];
                const unknownTrades = [];
                let totalBuy = 0, totalSell = 0, totalGasCost = 0;
                
                // ç¡®ä¿bnbPriceæ˜¯æœ‰æ•ˆçš„æ•°å­—
                if (isNaN(bnbPrice) || bnbPrice <= 0) {
                    console.warn(`æ£€æµ‹åˆ°æ— æ•ˆçš„BNBä»·æ ¼: ${bnbPrice}ï¼Œä½¿ç”¨é»˜è®¤ä»·æ ¼660`);
                    bnbPrice = 660;
                }
                
                // ğŸš€ æ‰¹é‡å¤„ç†USDTè½¬è´¦ - å‚è€ƒalpha.dogçš„é«˜æ•ˆæ–¹å¼
                console.log(`ğŸš€ å¼€å§‹æ‰¹é‡å¤„ç† ${grouped.length} ä¸ªäº¤æ˜“ç»„...`);
                
                // æ·»åŠ è½¬è´¦ç±»å‹åˆ¤æ–­å‡½æ•°
                function isSimpleUSDTTransfer(tx) {
                    // 1. æ£€æŸ¥æ˜¯å¦æ¶‰åŠDEXè·¯ç”±
                    if (DEX_ROUTER_LIST.includes(tx.to?.toLowerCase()) || 
                        DEX_ROUTER_LIST.includes(tx.from?.toLowerCase())) {
                        return false;
                    }
                    
                    // 2. æ£€æŸ¥inputæ˜¯å¦ä¸ºå¤æ‚è°ƒç”¨
                    if (tx.input && tx.input.length > 10) {
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        const swapMethods = [
                            '0xa03de6a9', '0x7c025200', '0x84bd6d29', '0x12aa3caf',
                            '0xe5e8894b', '0x7ff36ab5', '0x38ed1739', '0x18cbafe5'
                        ];
                        if (swapMethods.includes(methodId)) {
                            return false;
                        }
                        if (methodId === '0xa9059cbb') {
                            return true;
                        }
                    }
                    
                    // 3. å¦‚æœtoåœ°å€æ˜¯USDTåˆçº¦ï¼Œä¸”æ˜¯ç®€å•è°ƒç”¨
                    if (tx.to?.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                        return true;
                    }
                    
                    return false;
                }
                
                // ç­›é€‰å‡ºéœ€è¦è·å–Receiptçš„äº¤æ˜“
                const needReceiptTxs = [];
                const directProcessTxs = [];
                
                for (const txGroup of grouped) {
                    const tx = txGroup[0];
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºæ™®é€šè½¬è´¦
                    if (isSimpleUSDTTransfer(tx)) {
                        console.log(`ğŸ“¤ è·³è¿‡æ™®é€šUSDTè½¬è´¦: ${tx.hash}`);
                        unknownTrades.push({
                            hash: tx.hash,
                            timestamp: tx.timeStamp,
                            methodId: 'simple_transfer',
                            gasCost: GasUtils.calculateGasFromTx(tx),
                            tokenAddress: USDT_CONTRACT,
                            note: 'æ™®é€šUSDTè½¬è´¦ï¼ˆæœªè®¡å…¥ä¹°å–ç»Ÿè®¡ï¼‰'
                        });
                        continue;
                    }
                    
                    if (tx.contractAddress?.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                        if (tx.value && tx.value !== '0') {
                            // å¯ä»¥ç›´æ¥å¤„ç†çš„USDTäº¤æ˜“
                            directProcessTxs.push({ txGroup, tx, amount: parseFloat(tx.value) / 1e18 });
                        } else {
                            // éœ€è¦ä»Receiptè§£æçš„äº¤æ˜“
                            needReceiptTxs.push({ txGroup, tx });
                        }
                    }
                }
                
                console.log(`ğŸ“Š å¤„ç†åˆ†ç±»: ç›´æ¥å¤„ç†${directProcessTxs.length}ä¸ª, éœ€è¦Receipt${needReceiptTxs.length}ä¸ª`);
                
                // å¤„ç†å¯ä»¥ç›´æ¥å¤„ç†çš„äº¤æ˜“
                for (const { txGroup, tx, amount } of directProcessTxs) {
                    const time = parseInt(tx.timeStamp);
                    
                    if (amount <= 0) continue;
                    
                    // ä½¿ç”¨GasUtilsè®¡ç®—çœŸå®gasè´¹ç”¨
                    const realGasCost = GasUtils.calculateGasFromTx(tx);
                    
                    let trade = null;
                    if (tx.from?.toLowerCase() === address) {
                        trade = {
                            hash: tx.hash,
                            usdtAmount: -amount,
                            tokenAmount: 0,
                            tokenAddress: USDT_CONTRACT,
                            isBuy: true,
                            isSell: false,
                            timestamp: time,
                            gasCost: realGasCost // ä½¿ç”¨ä»äº¤æ˜“è®°å½•è®¡ç®—çš„çœŸå®Gasè´¹ç”¨
                        };
                        totalBuy += amount;
                    } else if (tx.to?.toLowerCase() === address) {
                        trade = {
                            hash: tx.hash,
                            usdtAmount: amount,
                            tokenAmount: 0,
                            tokenAddress: USDT_CONTRACT,
                            isBuy: false,
                            isSell: true,
                            timestamp: time,
                            gasCost: realGasCost // ä½¿ç”¨ä»äº¤æ˜“è®°å½•è®¡ç®—çš„çœŸå®Gasè´¹ç”¨
                        };
                        totalSell += amount;
                    }
                    
                    if (trade) {
                        trades.push(trade);
                        totalGasCost += trade.gasCost;
                        console.log(`âœ… ç›´æ¥å¤„ç†: ${tx.hash}, ${amount} USDT, ${trade.isBuy ? 'ä¹°å…¥' : 'å–å‡º'}, Gas: ${realGasCost.toFixed(6)} BNB`);
                    }
                }
                
                // æ‰¹é‡è·å–éœ€è¦Receiptçš„äº¤æ˜“
                if (needReceiptTxs.length > 0) {
                    console.log(`ğŸ“¦ æ‰¹é‡è·å– ${needReceiptTxs.length} ä¸ªäº¤æ˜“çš„Receipt...`);
                    const txHashes = needReceiptTxs.map(item => item.tx.hash);
                    const receiptResults = await batchGetTxReceipts(txHashes);
                    
                    // å¤„ç†Receiptç»“æœ
                    for (let i = 0; i < needReceiptTxs.length; i++) {
                        const { txGroup, tx } = needReceiptTxs[i];
                        const { receipt } = receiptResults[i];
                        const time = parseInt(tx.timeStamp);
                        
                        // ä½¿ç”¨GasUtilsè®¡ç®—çœŸå®gasè´¹ç”¨
                        const realGasCost = GasUtils.calculateGasFromTx(tx);
                        
                        if (!receipt) {
                            console.log(`âš ï¸ è·³è¿‡æ— Receiptçš„äº¤æ˜“: ${tx.hash}`);
                            continue;
                        }
                        
                        const transferInfo = parseUSDTTransferFromReceipt(receipt, addressInfo.address);
                        
                        if (!transferInfo || transferInfo.amount <= 0) {
                            console.log(`âš ï¸ è·³è¿‡æ— æ•ˆTransferçš„äº¤æ˜“: ${tx.hash}`);
                            continue;
                        }
                        
                        let trade = null;
                        if (transferInfo.isOutgoing) {
                            trade = {
                                hash: tx.hash,
                                usdtAmount: -transferInfo.amount,
                                tokenAmount: 0,
                                tokenAddress: USDT_CONTRACT,
                                isBuy: true,
                                isSell: false,
                                timestamp: time,
                                gasCost: realGasCost // ä½¿ç”¨ä»äº¤æ˜“è®°å½•è®¡ç®—çš„çœŸå®Gasè´¹ç”¨
                            };
                            totalBuy += transferInfo.amount;
                        } else if (transferInfo.isIncoming) {
                            trade = {
                                hash: tx.hash,
                                usdtAmount: transferInfo.amount,
                                tokenAmount: 0,
                                tokenAddress: USDT_CONTRACT,
                                isBuy: false,
                                isSell: true,
                                timestamp: time,
                                gasCost: realGasCost // ä½¿ç”¨ä»äº¤æ˜“è®°å½•è®¡ç®—çš„çœŸå®Gasè´¹ç”¨
                            };
                            totalSell += transferInfo.amount;
                        }
                        
                        if (trade) {
                            trades.push(trade);
                            totalGasCost += trade.gasCost;
                            console.log(`âœ… Receiptå¤„ç†: ${tx.hash}, ${transferInfo.amount} USDT, ${trade.isBuy ? 'ä¹°å…¥' : 'å–å‡º'}, Gas: ${realGasCost.toFixed(6)} BNB`);
                        }
                    }
                }
                
                console.log(`ğŸ¯ ${addressInfo.name} æ‰¹é‡å¤„ç†å®Œæˆ: ${trades.length}ç¬”äº¤æ˜“`);
                
                document.getElementById('loading-detail').textContent = 'åˆ†æå®Œæˆ';
                
                // è®¡ç®—ç»“æœ
                const gasCostInUSDT = totalGasCost * bnbPrice;
                const profitLoss = totalSell - totalBuy;
                const netProfitLoss = profitLoss - gasCostInUSDT;
                
                console.log(`ğŸ“Š ${addressInfo.name} åˆ†æç»“æœ: ä¹°å…¥${totalBuy.toFixed(2)} å–å‡º${totalSell.toFixed(2)} Gas${totalGasCost.toFixed(4)}BNB`);
                
                // æ·»åŠ è¯¦ç»†çš„åˆ†ææ‘˜è¦
                console.log(`ğŸ“‹ ${addressInfo.name} è¯¦ç»†æ‘˜è¦:`);
                console.log(`   ğŸ“¦ äº¤æ˜“æ€»æ•°: ${relevantTransfers.length}`);
                console.log(`   âœ… å·²è¯†åˆ«äº¤æ˜“: ${trades.length}`);
                console.log(`   â“ æœªè¯†åˆ«äº¤æ˜“: ${unknownTrades.length}`);
                console.log(`   ğŸ’° ä¹°å…¥æ“ä½œ: ${trades.filter(t => t.isBuy).length}æ¬¡ï¼Œæ€»é¢: ${totalBuy.toFixed(2)} USDT`);
                console.log(`   ğŸ’¸ å–å‡ºæ“ä½œ: ${trades.filter(t => t.isSell).length}æ¬¡ï¼Œæ€»é¢: ${totalSell.toFixed(2)} USDT`);
                console.log(`   ğŸ“ˆ å‡€ç›ˆäº: ${profitLoss.toFixed(2)} USDT (æ‰£é™¤Gaså‰)`);
                console.log(`   ğŸ“‰ å®é™…ç›ˆäº: ${netProfitLoss.toFixed(2)} USDT (æ‰£é™¤Gaså)`);
                
                return {
                    name: addressInfo.name,
                    address: addressInfo.address,
                    trades,
                    unknownTrades,
                    totalBuyValue: totalBuy,
                    totalSellValue: totalSell,
                    profitLoss: profitLoss,
                    netProfitLoss: netProfitLoss,
                    totalGasCost: totalGasCost,
                    gasCostInUSDT: gasCostInUSDT,
                    bnbPrice: bnbPrice,
                    usdtPrice: usdtPrice,
                    usdtBalance: parseFloat(usdtBalance),
                    timeRange
                };
            }
            
            async function renderResults(data) {
                const { addressEntries, allAnalysis } = data;
                const accountsContainer = document.getElementById('accountsContainer');
                accountsContainer.innerHTML = '';

                // è®¡ç®—æ€»äºæŸå’Œæ˜¯å¦æœ‰äº¤æ˜“
                let totalLoss = 0;
                let totalTrades = 0;
                allAnalysis.forEach(analysis => {
                    totalLoss += analysis.netProfitLoss < 0 ? Math.abs(analysis.netProfitLoss) : 0;
                    totalTrades += analysis.trades.length;
                });

                // ä»ç¬¬ä¸€ä¸ªåˆ†æç»“æœä¸­è·å–timeRangeï¼ˆæ‰€æœ‰åˆ†æåº”è¯¥ä½¿ç”¨ç›¸åŒçš„æ—¶é—´èŒƒå›´ï¼‰
                const timeRange = allAnalysis.length > 0 ? allAnalysis[0].timeRange : null;

                // æ›´æ–°æ—¶é—´èŒƒå›´æ˜¾ç¤ºï¼ˆç¡®ä¿timeRangeå­˜åœ¨ï¼‰
                if (timeRange) {
                    document.getElementById('timeRangeInfo').textContent = 
                        `ç»Ÿè®¡æ—¶é—´: ${formatDateTime(timeRange.startDate)} è‡³ ${formatDateTime(timeRange.endDate)}`;
                }

                // ä¿®æ”¹æ¸²æŸ“ç»“æœå‡½æ•°ä¸­çš„æ€»ç»“å¡ç‰‡é€»è¾‘
                const summaryCard = document.createElement('div');
                summaryCard.className = 'card mb-4';

                if (totalTrades === 0) {
                    summaryCard.innerHTML = `
                        <div class="card-body bg-info text-white">
                            <h5 class="card-title">âš ï¸ æœªæ£€æµ‹åˆ°äº¤æ˜“è®°å½•</h5>
                            <p class="mb-0">å¯èƒ½åŸå› ï¼š</p>
                            <ul class="mb-0">
                                <li>ä»Šæ—¥æœªè¿›è¡Œäº¤æ˜“</li>
                                <li>API è®¿é—®å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•</li>
                                <li>é€‰æ‹©çš„æ—¶é—´èŒƒå›´å†…æ— äº¤æ˜“</li>
                            </ul>
                        </div>
                    `;
                } else {
                    // è®¡ç®—æ€»ç›ˆäº
                    let totalProfit = 0;
                    allAnalysis.forEach(analysis => {
                        totalProfit += analysis.netProfitLoss;
                    });
                    
                    // æ ¹æ®ç›ˆäºæƒ…å†µæ˜¾ç¤ºä¸åŒçš„ä¿¡æ¯
                    if (totalProfit > 0) {
                        // ç›ˆåˆ©æƒ…å†µ
                        const teaEggs = Math.floor(totalProfit / 0.5); // å‡è®¾èŒ¶å¶è›‹0.5Uä¸€ä¸ª
                        summaryCard.innerHTML = `
                            <div class="card-body bg-success text-white">
                                <h5 class="card-title">ğŸ‰ æ­å–œä½ è¿™ä¸ªäº¤æ˜“å¤©æ‰ï¼ä»Šæ—¥ç›ˆåˆ© ${totalProfit.toFixed(2)} USDT</h5>
                                <p class="mb-0">ç›¸å½“äºèµšäº† ${teaEggs} ä¸ªèŒ¶å¶è›‹ (æŒ‰0.5U/ä¸ªè®¡ç®—)</p>
                                <small>ç»§ç»­ä¿æŒè¿™æ ·çš„æ°´å¹³ï¼</small>
                            </div>
                        `;
                    } else if (totalProfit === 0) {
                        // æ”¶æ”¯å¹³è¡¡
                        summaryCard.innerHTML = `
                            <div class="card-body bg-warning">
                                <h5 class="card-title">ğŸ˜ ä»Šæ—¥æ”¶æ”¯å¹³è¡¡ ${totalProfit.toFixed(2)} USDT</h5>
                                <p class="mb-0">ä¸èµšä¸äºï¼Œä¿æŒç¨³å®š</p>
                                <small class="text-muted">æ˜å¤©äº‰å–æœ‰æ‰€çªç ´ï¼</small>
                            </div>
                        `;
                    } else if (Math.abs(totalProfit) < 5) {
                        // å°äº
                        const pigFeetMeals = Math.ceil(Math.abs(totalProfit) / 2);
                        summaryCard.innerHTML = `
                            <div class="card-body bg-warning">
                                <h5 class="card-title">ğŸ˜… ä»Šæ—¥å°äº ${Math.abs(totalProfit).toFixed(2)} USDT</h5>
                                <p class="mb-0">ç›¸å½“äºä¸¢å¤±äº† ${pigFeetMeals} é¡¿çŒªè„šé¥­ (æŒ‰2U/é¡¿è®¡ç®—)</p>
                                <small class="text-muted">åˆ«ç°å¿ƒï¼Œæ˜å¤©ä¼šæ›´å¥½ï¼</small>
                            </div>
                        `;
                    } else if (Math.abs(totalProfit) >= 50) {
                        // å¤§äº
                        const hotPotMeals = Math.ceil(Math.abs(totalProfit) / 50);
                        summaryCard.innerHTML = `
                            <div class="card-body bg-danger text-white">
                                <h5 class="card-title">ğŸ˜± ä»Šæ—¥å¤§äº ${Math.abs(totalProfit).toFixed(2)} USDT</h5>
                                <p class="mb-0">ç›¸å½“äºé”™è¿‡äº† ${hotPotMeals} é¡¿æµ·åº•æ (æŒ‰50U/é¡¿è®¡ç®—)</p>
                                <small>å»ºè®®ä¼‘æ¯ä¸€ä¸‹ï¼Œè°ƒæ•´å¿ƒæ€ï¼</small>
                            </div>
                        `;
                    } else {
                        // ä¸­ç­‰äºæŸ
                        const pigFeetMeals = Math.ceil(Math.abs(totalProfit) / 2);
                        summaryCard.innerHTML = `
                            <div class="card-body bg-warning">
                                <h5 class="card-title">ğŸ˜“ ä»Šæ—¥äºæŸ ${Math.abs(totalProfit).toFixed(2)} USDT</h5>
                                <p class="mb-0">ç›¸å½“äºä¸¢å¤±äº† ${pigFeetMeals} é¡¿çŒªè„šé¥­ (æŒ‰2U/é¡¿è®¡ç®—)</p>
                                <small class="text-muted">è°ƒæ•´ç­–ç•¥ï¼Œæ˜å¤©ç»§ç»­ï¼</small>
                            </div>
                        `;
                    }
                }

                // å°†æ€»ç»“å¡ç‰‡æ’å…¥åˆ°ç»“æœå®¹å™¨çš„å¼€å¤´
                accountsContainer.insertBefore(summaryCard, accountsContainer.firstChild);

                // ç»§ç»­æ¸²æŸ“åŸæœ‰çš„è´¦æˆ·åˆ†æç»“æœ
                for (let i = 0; i < addressEntries.length; i++) {
                    const entry = addressEntries[i];
                    const analysis = allAnalysis[i];
                    // è·å–å½“å‰USDTä½™é¢
                    const balance = await getUSDTBalance(entry.address);
                    
                    const accountCard = document.createElement('div');
                    accountCard.className = 'card mb-4';
                    accountCard.id = `accountCard_${i}`; // æ·»åŠ IDä»¥ä¾¿åç»­å¼•ç”¨
                    accountCard.innerHTML = `
                        <div class="card-header bg-light">
                            <h5 class="mb-0">
                                <i class="bi bi-person-circle"></i> 
                                ${entry.name}
                                <small class="text-muted">${entry.address}</small>
                            </h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="stats-box bg-light">
                                        <h6 class="border-bottom pb-2">USDTä¹°å–ç»Ÿè®¡</h6>
                                        <div class="d-flex justify-content-between">
                                            <span>ä¹°å…¥æ€»é¢:</span>
                                            <span class="fw-bold usdt-out">${analysis.totalBuyValue.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>å–å‡ºæ€»é¢:</span>
                                            <span class="fw-bold usdt-in">${analysis.totalSellValue.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>å‡€ç›ˆäº:</span>
                                            <span class="fw-bold ${analysis.netProfitLoss >= 0 ? 'usdt-in' : 'usdt-out'}">${analysis.netProfitLoss.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>å½“å‰USDTä½™é¢:</span>
                                            <span class="fw-bold">${balance.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>æ€»Gasæ¶ˆè€—:</span>
                                            <span class="fw-bold">${analysis.totalGasCost.toFixed(6)} BNB â‰ˆ ${analysis.gasCostInUSDT.toFixed(2)} USDT</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-8">
                                    <div class="stats-box bg-light">
                                        <h6 class="border-bottom pb-2">USDTä¹°å–æ˜ç»†</h6>
                                        <div class="table-responsive">
                                            <table class="table table-sm table-bordered">
                                                <thead>
                                                    <tr>
                                                        <th>æ—¶é—´</th>
                                                        <th>ç±»å‹</th>
                                                        <th>USDTé‡‘é¢</th>
                                                        <th>ä»£å¸é‡‘é¢</th>
                                                        <th>ä»£å¸åˆçº¦</th>
                                                        <th>äº¤æ˜“</th>
                                                        <th>Gasè´¹ç”¨ï¼ˆBNBï¼‰</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    ${
                                                        analysis.trades.length === 0
                                                        ? '<tr><td colspan="7">æ— USDTä¹°å–è®°å½•</td></tr>'
                                                        : analysis.trades.map(d => `
                                                            <tr>
                                                                <td>${formatTime(d.timestamp)}</td>
                                                                <td class="${d.isSpecial ? '' : (d.usdtAmount < 0 ? 'usdt-out' : 'usdt-in')}">
                                                                    ${d.isSpecial ? 'ç‰¹æ®ŠUSDTäº¤æ˜“' : (d.usdtAmount < 0 ? 'ç”¨USDTä¹°å…¥' : 'ç”¨å…¶ä»–å¸æ¢USDT')}
                                                                    ${d.methodId ? `<small class="text-muted">(${d.methodId})</small>` : ''}
                                                                </td>
                                                                <td>${d.isSpecial ? '-' : Math.abs(d.usdtAmount).toFixed(6)}</td>
                                                                <td>${d.tokenAmount.toFixed(6)}</td>
                                                                <td class="ellipsis" title="${d.tokenAddress}">${d.tokenAddress}</td>
                                                                <td><a href="https://bscscan.com/tx/${d.hash}" target="_blank">æŸ¥çœ‹</a></td>
                                                                <td>${d.gasCost ? d.gasCost.toFixed(6) : '-'}</td>
                                                            </tr>
                                                        `).join('')
                                                    }
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    accountsContainer.appendChild(accountCard);

                    // æ¸²æŸ“æœªè¯†åˆ«äº¤æ˜“
                    if (analysis.unknownTrades && analysis.unknownTrades.length > 0) {
                        renderUnknownTrades(i, analysis.unknownTrades, entry);
                    }
                }
                console.log('æ¸²æŸ“åˆ†æç»“æœï¼š', allAnalysis);
            }

            function groupByHash(transfers) {
                const map = {};
                for (const tx of transfers) {
                    if (!map[tx.hash]) map[tx.hash] = [];
                    map[tx.hash].push(tx);
                }
                return Object.values(map);
            }

            function analyzeUSDTTrades(address, groupedTxs, timeRange) {
                const trades = [];
                let totalBuy = 0, totalSell = 0;
                for (const txGroup of groupedTxs) {
                    // å–æ¶ˆè·¯ç”±è¿‡æ»¤
                    // const isSwap = txGroup.some(tx =>
                    //     DEX_ROUTER_LIST.includes(tx.to.toLowerCase()) ||
                    //     DEX_ROUTER_LIST.includes(tx.from.toLowerCase())
                    // );
                    // if (!isSwap) continue;

                    // æ—¶é—´è¿‡æ»¤
                    const time = parseInt(txGroup[0].timeStamp);
                    if (time < timeRange.start || time >= timeRange.end) continue;

                    let usdtIn = 0, usdtOut = 0;
                    let hash = txGroup[0].hash;
                    let tokenAddress = txGroup[0].contractAddress;
                    for (const tx of txGroup) {
                        if (tx.to.toLowerCase() === address.toLowerCase()) {
                            usdtIn += parseFloat(tx.value) / 1e18;
                        }
                        if (tx.from.toLowerCase() === address.toLowerCase()) {
                            usdtOut += parseFloat(tx.value) / 1e18;
                        }
                    }
                    if (usdtOut > 0) {
                        trades.push({
                            hash,
                            usdtAmount: -usdtOut,
                            tokenAmount: 0,
                            tokenAddress,
                            isBuy: true,
                            isSell: false,
                            timestamp: time
                        });
                        totalBuy += usdtOut;
                    }
                    if (usdtIn > 0) {
                        trades.push({
                            hash,
                            usdtAmount: usdtIn,
                            tokenAmount: 0,
                            tokenAddress,
                            isBuy: false,
                            isSell: true,
                            timestamp: time
                        });
                        totalSell += usdtIn;
                    }
                }
                return { trades, totalBuy, totalSell };
            }

            // ä¿®æ”¹analyzeTxGroupå‡½æ•°ï¼Œç¡®ä¿ä¸ä¼šä¸¢å¤±å–å‡ºäº¤æ˜“
            async function analyzeTxGroup(txGroup, address) {
                const tx = txGroup[0];
                const receipt = await getTxReceipt(tx.hash);
                if (!receipt || !receipt.logs) {
                    console.log(`ã€${address}ã€‘hash:${tx.hash} æ²¡æœ‰æ”¶æ®æˆ–logs`);
                    return null;
                }

                // è·å–ä¸»äº¤æ˜“è¯¦æƒ…
                const txDetail = await getTxDetail(tx.hash);
                if (!txDetail) {
                    console.log(`ã€${address}ã€‘hash:${tx.hash} æ²¡æœ‰ä¸»äº¤æ˜“è¯¦æƒ…`);
                    return null;
                }
                
                const methodId = txDetail.input ? txDetail.input.slice(0, 10).toLowerCase() : '';
                console.log(`äº¤æ˜“ ${tx.hash} æ–¹æ³•ID: ${methodId}`);
                
                // è®¡ç®—gasè´¹ç”¨ - ç¡®ä¿æ­£ç¡®å¤„ç†åå…­è¿›åˆ¶æ•°æ®
                let gasCost = 0;
                try {
                    const gasUsed = parseInt(receipt.gasUsed, 16);
                    const gasPrice = parseInt(txDetail.gasPrice, 16);
                    gasCost = gasUsed * gasPrice / 1e18;
                    console.log(`äº¤æ˜“ ${tx.hash} gasè´¹ç”¨: ${gasCost} BNB`);
                } catch (e) {
                    console.error(`è®¡ç®—gasè´¹ç”¨å‡ºé”™ ${tx.hash}:`, e);
                }

                const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                
                // ç¡®ä¿åœ°å€æ ¼å¼ç»Ÿä¸€ä¸ºå°å†™
                const normalizedAddress = address.toLowerCase();
                
                // åˆå§‹åŒ–USDTè½¬å…¥è½¬å‡ºå’Œå…¶ä»–ä»£å¸è½¬å…¥è½¬å‡ºçš„ç»Ÿè®¡
                let usdtIn = 0, usdtOut = 0, tokenIn = 0, tokenOut = 0, tokenAddress = '';

                // åˆ†ææ‰€æœ‰æ—¥å¿—
                for (const log of receipt.logs) {
                    if (log.topics[0] === ERC20_TRANSFER_TOPIC) {
                        const from = '0x' + log.topics[1].slice(26).toLowerCase();
                        const to = '0x' + log.topics[2].slice(26).toLowerCase();
                        
                        try {
                            const amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯USDTè½¬è´¦
                            if (log.address.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                                // USDTè½¬è´¦
                                if (from === normalizedAddress) {
                                    usdtOut += amount;
                                    console.log(`äº¤æ˜“ ${tx.hash} æ£€æµ‹åˆ°USDTè½¬å‡º: ${amount}`);
                                }
                                if (to === normalizedAddress) {
                                    usdtIn += amount;
                                    console.log(`äº¤æ˜“ ${tx.hash} æ£€æµ‹åˆ°USDTè½¬å…¥: ${amount}`);
                                }
                            } else {
                                // å…¶ä»–ä»£å¸è½¬è´¦
                                if (from === normalizedAddress) {
                                    tokenOut += amount;
                                    if (!tokenAddress) tokenAddress = log.address.toLowerCase();
                                    console.log(`äº¤æ˜“ ${tx.hash} æ£€æµ‹åˆ°ä»£å¸è½¬å‡º: ${amount}, åˆçº¦: ${log.address}`);
                                }
                                if (to === normalizedAddress) {
                                    tokenIn += amount;
                                    if (!tokenAddress) tokenAddress = log.address.toLowerCase();
                                    console.log(`äº¤æ˜“ ${tx.hash} æ£€æµ‹åˆ°ä»£å¸è½¬å…¥: ${amount}, åˆçº¦: ${log.address}`);
                                }
                            }
                        } catch (e) {
                            console.error(`è§£æä»£å¸é‡‘é¢é”™è¯¯: ${tx.hash}`, e);
                        }
                    }
                }
                
                // å¤„ç†æ™®é€šäº¤æ˜“çš„æƒ…å†µ
                // USDTè½¬å‡ºä¸”å…¶ä»–ä»£å¸è½¬å…¥ = ä¹°å…¥äº¤æ˜“
                if (usdtOut > 0 && tokenIn > 0) {
                    console.log(`âœ… æ£€æµ‹åˆ°ä¹°å…¥äº¤æ˜“ ${tx.hash}: æ”¯ä»˜${usdtOut} USDT, è·å¾—${tokenIn}ä»£å¸ (${tokenAddress})`);
                    return {
                        hash: tx.hash,
                        usdtAmount: -usdtOut,  // ç”¨è´Ÿæ•°è¡¨ç¤ºUSDTæ”¯å‡º
                        tokenAmount: tokenIn,
                        tokenAddress,
                        isBuy: true,
                        isSell: false,
                        timestamp: parseInt(tx.timeStamp),  // ç¡®ä¿è½¬æ¢ä¸ºæ•´æ•°
                        gasCost: gasCost
                    };
                }
                
                // USDTè½¬å…¥ä¸”å…¶ä»–ä»£å¸è½¬å‡º = å–å‡ºäº¤æ˜“
                if (usdtIn > 0 && tokenOut > 0) {
                    console.log(`âœ… æ£€æµ‹åˆ°å–å‡ºäº¤æ˜“ ${tx.hash}: æ”¯ä»˜${tokenOut}ä»£å¸, è·å¾—${usdtIn} USDT`);
                    return {
                        hash: tx.hash,
                        usdtAmount: usdtIn,  // æ­£æ•°è¡¨ç¤ºUSDTæ”¶å…¥
                        tokenAmount: -tokenOut,  // è´Ÿæ•°è¡¨ç¤ºä»£å¸æ”¯å‡º
                        tokenAddress,
                        isBuy: false,
                        isSell: true,
                        timestamp: parseInt(tx.timeStamp),  // ç¡®ä¿è½¬æ¢ä¸ºæ•´æ•°
                        gasCost: gasCost
                    };
                }
                
                // å¤„ç†åªæœ‰USDTè½¬å…¥çš„æƒ…å†µï¼ˆå¯èƒ½æ˜¯å–å‡ºä½†æœªæ£€æµ‹åˆ°ä»£å¸è½¬å‡ºï¼‰
                if (usdtIn > 0 && tokenOut === 0 && tokenIn === 0) {
                    console.log(`âš ï¸ æ£€æµ‹åˆ°USDTè½¬å…¥äº¤æ˜“ ${tx.hash}: è·å¾—${usdtIn} USDT, æœªæ£€æµ‹åˆ°ä»£å¸æµåŠ¨`);
                    return {
                        hash: tx.hash,
                        usdtAmount: usdtIn,
                        tokenAmount: 0,
                        tokenAddress: tokenAddress || USDT_CONTRACT,
                        isBuy: false,
                        isSell: true,
                        timestamp: parseInt(tx.timeStamp),
                        gasCost: gasCost
                    };
                }
                
                // å¤„ç†åªæœ‰USDTè½¬å‡ºçš„æƒ…å†µï¼ˆå¯èƒ½æ˜¯ä¹°å…¥ä½†æœªæ£€æµ‹åˆ°ä»£å¸è½¬å…¥ï¼‰
                if (usdtOut > 0 && tokenIn === 0 && tokenOut === 0) {
                    console.log(`âš ï¸ æ£€æµ‹åˆ°USDTè½¬å‡ºäº¤æ˜“ ${tx.hash}: æ”¯ä»˜${usdtOut} USDT, æœªæ£€æµ‹åˆ°ä»£å¸æµåŠ¨`);
                    return {
                        hash: tx.hash,
                        usdtAmount: -usdtOut,
                        tokenAmount: 0,
                        tokenAddress: tokenAddress || USDT_CONTRACT,
                        isBuy: true,
                        isSell: false,
                        timestamp: parseInt(tx.timeStamp),
                        gasCost: gasCost
                    };
                }
                
                // å¤„ç†ç‰¹æ®Šæ–¹æ³•IDäº¤æ˜“...
                // (ä¿ç•™ç°æœ‰çš„ç‰¹æ®Šæ–¹æ³•IDå¤„ç†ä»£ç )
                
                // æ— æ³•æ˜ç¡®è¯†åˆ«çš„äº¤æ˜“
                return null;
            }

            // ä½¿ç”¨æ˜ç¡®çš„æ—¶é—´èŒƒå›´å‡½æ•°
            function getTimeRange(dateStr = '') {
                // è·å–åŒ—äº¬æ—¶é—´å½“å¤©8:00åˆ°æ¬¡æ—¥8:00çš„æ—¶é—´æˆ³åŒºé—´
                let startDate, endDate;

                if (dateStr) {
                    // ç”¨æˆ·è¾“å…¥æ—¥æœŸï¼Œè®¾ç½®ä¸ºæŒ‡å®šæ—¥æœŸçš„åŒ—äº¬æ—¶é—´8:00
                    startDate = new Date(`${dateStr}T08:00:00+08:00`);
                } else {
                    // æ­£ç¡®è·å–å½“å‰åŒ—äº¬æ—¶é—´ - ä¿®å¤æ—¶é—´æˆ³bug
                    const now = new Date();
                    
                    console.log(`ğŸ• å½“å‰æœ¬åœ°æ—¶é—´: ${now.toLocaleString()}`);
                    console.log(`ğŸ• å½“å‰UTCæ—¶é—´: ${now.toUTCString()}`);
                    
                    // è·å–åŒ—äº¬æ—¶é—´ï¼ˆUTC+8ï¼‰
                    const bjTime = new Date(now.getTime() + (8 * 60 * 60 * 1000) - (now.getTimezoneOffset() * 60 * 1000));
                    
                    console.log(`ğŸ• è®¡ç®—çš„åŒ—äº¬æ—¶é—´: ${bjTime.toLocaleString()}`);
                    console.log(`ğŸ• åŒ—äº¬æ—¶é—´å°æ—¶: ${bjTime.getHours()}`);
                    
                    // è·å–ä»Šå¤©åŒ—äº¬æ—¶é—´çš„æ—¥æœŸå­—ç¬¦ä¸² - ä½¿ç”¨æ­£ç¡®çš„æ–¹æ³•
                    const year = bjTime.getFullYear();
                    const month = (bjTime.getMonth() + 1).toString().padStart(2, '0');
                    const day = bjTime.getDate().toString().padStart(2, '0');
                    const bjToday = `${year}-${month}-${day}`;
                    
                    console.log(`ğŸ“… åŒ—äº¬ä»Šå¤©æ—¥æœŸ: ${bjToday}`);
                    console.log(`ğŸ”¢ åŒ—äº¬æ—¶é—´: ${year}-${month}-${day} ${bjTime.getHours()}:${bjTime.getMinutes()}`);
                    
                    // å¦‚æœåŒ—äº¬æ—¶é—´å°äº8ç‚¹ï¼Œä½¿ç”¨æ˜¨å¤©8ç‚¹å¼€å§‹
                    if (bjTime.getHours() < 8) {
                        console.log(`ğŸ• åŒ—äº¬æ—¶é—´æœªåˆ°8ç‚¹ï¼Œä½¿ç”¨æ˜¨å¤©8ç‚¹å¼€å§‹`);
                        const bjYesterday = new Date(bjTime);
                        bjYesterday.setDate(bjYesterday.getDate() - 1);
                        const yYear = bjYesterday.getFullYear();
                        const yMonth = (bjYesterday.getMonth() + 1).toString().padStart(2, '0');
                        const yDay = bjYesterday.getDate().toString().padStart(2, '0');
                        const yesterdayStr = `${yYear}-${yMonth}-${yDay}`;
                        console.log(`ğŸ“… æ˜¨å¤©æ—¥æœŸ: ${yesterdayStr}`);
                        startDate = new Date(`${yesterdayStr}T08:00:00+08:00`);
                    } else {
                        console.log(`ğŸ• åŒ—äº¬æ—¶é—´å·²è¿‡8ç‚¹ï¼Œä½¿ç”¨ä»Šå¤©8ç‚¹å¼€å§‹`);
                        console.log(`ğŸ“… ä½¿ç”¨æ—¥æœŸ: ${bjToday}`);
                        startDate = new Date(`${bjToday}T08:00:00+08:00`);
                    }
                }
                
                // ç»“æŸæ—¶é—´æ˜¯å¼€å§‹æ—¶é—´+24å°æ—¶
                endDate = new Date(startDate.getTime() + 24 * 60 * 60 * 1000);

                // è½¬ä¸ºç§’çº§æ—¶é—´æˆ³
                const start = Math.floor(startDate.getTime() / 1000);
                const end = Math.floor(endDate.getTime() / 1000);

                console.log(`ğŸ• æœ€ç»ˆæ—¶é—´èŒƒå›´è®¾ç½®:`);
                console.log(`   å¼€å§‹: ${startDate.toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})} (${start})`);
                console.log(`   ç»“æŸ: ${endDate.toLocaleString('zh-CN', {timeZone: 'Asia/Shanghai'})} (${end})`);
                console.log(`   æ€»æ—¶é•¿: ${(end - start) / 3600} å°æ—¶`);
                
                // éªŒè¯æ—¶é—´æˆ³æ˜¯å¦åˆç†ï¼ˆåº”è¯¥æ˜¯2023å¹´ï¼‰
                const startYear = new Date(start * 1000).getFullYear();
                const endYear = new Date(end * 1000).getFullYear();
                console.log(`ğŸ” æ—¶é—´æˆ³éªŒè¯: å¼€å§‹å¹´ä»½=${startYear}, ç»“æŸå¹´ä»½=${endYear}`);

                return {
                    start,
                    end,
                    startDate,
                    endDate
                };
            }

            // è·å–BNBä»·æ ¼
            async function getBNBPrice() {
                try {
                    const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT');
                    const data = await response.json();
                    const price = parseFloat(data.price);
                    
                    // ç¡®ä¿ä»·æ ¼æ˜¯æœ‰æ•ˆçš„æ•°å­—
                    if (!isNaN(price) && price > 0) {
                        console.log(`è·å–åˆ°å½“å‰BNBä»·æ ¼: ${price} USDT`);
                        return price;
                    } else {
                        console.warn(`è·å–åˆ°æ— æ•ˆçš„BNBä»·æ ¼: ${price}ï¼Œä½¿ç”¨é»˜è®¤ä»·æ ¼`);
                        return 220; // ä½¿ç”¨é»˜è®¤ä»·æ ¼
                    }
                } catch (error) {
                    console.error('è·å–BNBä»·æ ¼å¤±è´¥:', error);
                    return 220; // å‡ºé”™æ—¶ä½¿ç”¨é»˜è®¤ä»·æ ¼
                }
            }

            // 1. æ·»åŠ æ¸²æŸ“æœªè¯†åˆ«äº¤æ˜“çš„å‡½æ•° - æ”¾åœ¨renderResultså‡½æ•°ä¹‹å
            function renderUnknownTrades(index, unknownTrades, entry) {
                if (!unknownTrades || unknownTrades.length === 0) return;
                
                // åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨
                const container = document.createElement('div');
                container.className = 'mt-4';
                container.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center border-bottom pb-2">
                        <h6 class="mb-0">æœªè¯†åˆ«çš„USDTäº¤æ˜“ (${unknownTrades.length})</h6>
                        <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#unknownTradesCollapse_${index}">
                            <i class="bi bi-chevron-down"></i> å±•å¼€/æ”¶èµ·
                        </button>
                    </div>
                    <div class="collapse" id="unknownTradesCollapse_${index}">
                        <div class="alert alert-warning mt-2">
                            <i class="bi bi-exclamation-triangle"></i> 
                            ä»¥ä¸‹äº¤æ˜“æ— æ³•ç¡®å®šå…·ä½“ç±»å‹ï¼Œæœªè®¡å…¥ç»Ÿè®¡æ•°æ®
                        </div>
                        <div class="pt-2" id="unknownTradesContainer_${index}"></div>
                    </div>
                `;
                
                // å°†å®¹å™¨æ·»åŠ åˆ°è´¦æˆ·å¡ç‰‡
                const accountCard = document.querySelector(`#accountCard_${index}`);
                accountCard.appendChild(container);
                
                // æ¸²æŸ“æœªçŸ¥äº¤æ˜“
                const tradesContainer = document.getElementById(`unknownTradesContainer_${index}`);
                
                // å¯¹äº¤æ˜“æŒ‰æ—¶é—´å€’åºæ’åˆ—
                const sortedTrades = [...unknownTrades].sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                sortedTrades.forEach(trade => {
                    const tradeCard = document.createElement('div');
                    tradeCard.className = 'card trade-card border-warning';
                    
                    tradeCard.innerHTML = `
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h6 class="card-title mb-0">
                                        <i class="bi bi-question-circle text-warning"></i>
                                        æœªçŸ¥äº¤æ˜“ - æ–¹æ³•ID: ${trade.methodId || 'æœªçŸ¥'}
                                    </h6>
                                    <div class="mt-2">
                                        <div class="d-flex align-items-center">
                                            <span>åˆçº¦åœ°å€:</span>
                                            <span class="ms-2 ellipsis" title="${trade.tokenAddress || 'æœªçŸ¥'}">
                                                ${trade.tokenAddress || 'æœªçŸ¥'}
                                            </span>
                                        </div>
                                        <div class="d-flex align-items-center mt-1">
                                            <span>Gas è´¹ç”¨:</span>
                                            <span class="ms-2">
                                                ${trade.gasCost ? trade.gasCost.toFixed(6) : '-'} BNB
                                            </span>
                                        </div>
                                    </div>
                                </div>
                                <div class="text-end">
                                    <div class="text-muted mb-2">${formatTime(trade.timestamp)}</div>
                                    <a href="https://bscscan.com/tx/${trade.hash}" target="_blank" class="btn btn-sm btn-outline-secondary">
                                        <i class="bi bi-box-arrow-up-right"></i> æŸ¥çœ‹äº¤æ˜“
                                    </a>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    tradesContainer.appendChild(tradeCard);
                });
            }

            // ä¼˜åŒ–Receiptè·å– - æ‰¹é‡å¤„ç†å’Œç¼“å­˜
            async function batchGetTxReceipts(txHashes) {
                const results = [];
                const needFetchHashes = [];
                
                // é¦–å…ˆæ£€æŸ¥ç¼“å­˜
                for (const hash of txHashes) {
                    if (receiptCache.has(hash)) {
                        results.push({ hash, receipt: receiptCache.get(hash) });
                    } else {
                        needFetchHashes.push(hash);
                        results.push({ hash, receipt: null }); // å ä½ç¬¦
                    }
                }
                
                // åªè·å–ç¼“å­˜ä¸­æ²¡æœ‰çš„Receipt
                if (needFetchHashes.length > 0) {
                    console.log(`ğŸ“¦ éœ€è¦è·å– ${needFetchHashes.length} ä¸ªæ–°Receipt (${txHashes.length - needFetchHashes.length} ä¸ªå·²ç¼“å­˜)`);
                    
                    const batchSize = 5;
                    for (let i = 0; i < needFetchHashes.length; i += batchSize) {
                        const batch = needFetchHashes.slice(i, i + batchSize);
                        console.log(`ğŸ“¦ æ‰¹é‡è·å–Receipt: ${i+1}-${Math.min(i+batchSize, needFetchHashes.length)}/${needFetchHashes.length}`);
                        
                        const batchPromises = batch.map(async (hash) => {
                            try {
                                await sleep(150); // å‡å°‘å»¶è¿Ÿï¼Œå› ä¸ºå·²ç»åœ¨Gasè®¡ç®—ä¸­æœ‰å»¶è¿Ÿäº†
                                const receipt = await getTxReceipt(hash);
                                return { hash, receipt };
                            } catch (e) {
                                console.warn(`âš ï¸ è·å–Receiptå¤±è´¥: ${hash.slice(0, 10)}...`);
                                return { hash, receipt: null };
                            }
                        });
                        
                        const batchResults = await Promise.all(batchPromises);
                        
                        // æ›´æ–°ç»“æœæ•°ç»„ä¸­å¯¹åº”çš„ä½ç½®
                        for (const { hash, receipt } of batchResults) {
                            const index = txHashes.indexOf(hash);
                            if (index !== -1) {
                                results[index] = { hash, receipt };
                            }
                        }
                        
                        // æ‰¹æ¬¡é—´å»¶è¿Ÿ
                        if (i + batchSize < needFetchHashes.length) {
                            await sleep(400);
                        }
                    }
                } else {
                    console.log(`ğŸ“¦ æ‰€æœ‰Receiptå‡å·²ç¼“å­˜ï¼Œæ— éœ€é¢å¤–è·å–`);
                }
                
                return results;
            }
            
            // è§£æUSDT Transferäº‹ä»¶çš„ä¸“ç”¨å‡½æ•°
            function parseUSDTTransferFromReceipt(receipt, targetAddress) {
                if (!receipt || !receipt.logs) return null;
                
                const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                const usdtTransferLogs = receipt.logs.filter(log => 
                    log.address.toLowerCase() === USDT_CONTRACT.toLowerCase() && 
                    log.topics[0] === ERC20_TRANSFER_TOPIC
                );
                
                for (const log of usdtTransferLogs) {
                    try {
                        const from = '0x' + log.topics[1].slice(26).toLowerCase();
                        const to = '0x' + log.topics[2].slice(26).toLowerCase();
                        const amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ç›®æ ‡åœ°å€ç›¸å…³
                        if (from === targetAddress.toLowerCase() || to === targetAddress.toLowerCase()) {
                            return {
                                from,
                                to,
                                amount,
                                isOutgoing: from === targetAddress.toLowerCase(),
                                isIncoming: to === targetAddress.toLowerCase()
                            };
                        }
                    } catch (e) {
                        console.warn(`âš ï¸ è§£æTransferäº‹ä»¶å¤±è´¥:`, e);
                        continue;
                    }
                }
                
                return null;
            }

            /**
             * APIç›¸å…³å·¥å…·å‡½æ•° - å‚è€ƒalpha.dogçš„é«˜æ•ˆæ¨¡å¼
             */
            class USDTApiUtils {
                static BSC_SCAN_API_URL = 'https://api.bscscan.com/api';
                static USDT_CONTRACT = '0x55d398326f99059fF775485246999027B3197955'.toLowerCase();
                
                /**
                 * ä»BSCScan APIè·å–äº¤æ˜“ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
                 * @param {string} address - åœ°å€
                 * @param {string} action - æ“ä½œç±»å‹ (txlist, txlistinternal, tokentx)
                 * @param {Object} options - é¢å¤–é€‰é¡¹
                 * @returns {Promise<Array>} äº¤æ˜“åˆ—è¡¨
                 */
                static async fetchTransactions(address, action, options = {}) {
                    const {
                        contractAddress = null,
                        startBlock = 0,
                        endBlock = 99999999,
                        apiKey = getRandomApiKey(),
                        maxRetries = 3
                    } = options;
                    
                    let retries = maxRetries;
                    
                    while (retries > 0) {
                        try {
                            let url = `${this.BSC_SCAN_API_URL}?module=account&action=${action}&address=${address}&startblock=${startBlock}&endblock=${endBlock}&sort=desc&apikey=${apiKey}`;
                            
                            // å¦‚æœæ˜¯ä»£å¸äº¤æ˜“ï¼Œæ·»åŠ åˆçº¦åœ°å€
                            if (action === 'tokentx' && contractAddress) {
                                url += `&contractaddress=${contractAddress}`;
                            }
                            
                            console.log(`ğŸ“¡ APIè¯·æ±‚ [${action}]: ${address.slice(0, 8)}...`);
                            
                            const response = await fetch(url);
                            const data = await response.json();
                            
                            if (data.status === '1') {
                                console.log(`âœ… ${action}: ${data.result?.length || 0}æ¡è®°å½•`);
                                return data.result || [];
                            } else if (data.status === "0" && data.message === "No transactions found") {
                                console.log(`â„¹ï¸ ${action}: æ— äº¤æ˜“è®°å½•`);
                                return [];
                            } else if (data.status === "0" && (data.message === "NOTOK" || data.message.includes("rate limit"))) {
                                console.warn(`âš ï¸ ${action} APIé™åˆ¶ï¼Œç­‰å¾…é‡è¯•... å‰©ä½™${retries-1}æ¬¡`);
                                retries--;
                                if (retries > 0) {
                                    await sleep(2000 + Math.random() * 2000); // 2-4ç§’éšæœºå»¶è¿Ÿ
                                    continue;
                                }
                            } else {
                                console.warn(`âš ï¸ ${action} APIé”™è¯¯:`, data.message);
                                return [];
                            }
                        } catch (error) {
                            console.error(`âŒ ${action} è¯·æ±‚å¤±è´¥:`, error.message);
                            retries--;
                            if (retries > 0) {
                                await sleep(1000);
                            }
                        }
                    }
                    
                    console.error(`âŒ ${action} æœ€ç»ˆå¤±è´¥ï¼Œå·²ç”¨å°½æ‰€æœ‰é‡è¯•`);
                    return [];
                }
                
                /**
                 * è·å–åœ°å€çš„å®Œæ•´äº¤æ˜“æ•°æ®ï¼ˆä¸‰ç§ç±»å‹ï¼‰
                 * @param {string} address - åœ°å€
                 * @param {Object} timeRange - æ—¶é—´èŒƒå›´
                 * @returns {Promise<Object>} åˆ†ç±»çš„äº¤æ˜“æ•°æ®
                 */
                static async fetchAddressData(address, timeRange) {
                    try {
                        console.log(`ğŸš€ è·å– ${address.slice(0, 8)}... çš„å®Œæ•´äº¤æ˜“æ•°æ®ï¼ˆUSDT+USDCï¼‰`);
                        
                        // è®¡ç®—åŒºå—èŒƒå›´
                        let startBlock, endBlock;
                        try {
                            [startBlock, endBlock] = await Promise.all([
                                getBlockByTimestamp(timeRange.start, 'before'),
                                getBlockByTimestamp(timeRange.end, 'after')
                            ]);
                        } catch (e) {
                            console.warn(`âš ï¸ åŒºå—å·è·å–å¤±è´¥ï¼Œä½¿ç”¨å›ºå®šèŒƒå›´`);
                            startBlock = 50000000;
                            endBlock = 50300000;
                        }
                        
                        const options = { startBlock, endBlock };
                        
                        // å¹¶è¡Œè·å–æ™®é€šäº¤æ˜“å’Œå†…éƒ¨äº¤æ˜“
                        console.log(`ğŸ“¦ è·å–æ™®é€šäº¤æ˜“...`);
                        const normalTxList = await this.fetchTransactions(address, 'txlist', options);
                        
                        await sleep(1000); // 1ç§’é—´éš”
                        
                        console.log(`ğŸ“¦ è·å–å†…éƒ¨äº¤æ˜“...`);
                        const internalTxList = await this.fetchTransactions(address, 'txlistinternal', options);
                        
                        await sleep(1000); // 1ç§’é—´éš”
                        
                        // ğŸš€ æ–°å¢ï¼šå¹¶è¡Œè·å–USDTå’ŒUSDCä»£å¸äº¤æ˜“
                        console.log(`ğŸ“¦ è·å–USDTä»£å¸äº¤æ˜“...`);
                        const usdtTokenTxList = await this.fetchTransactions(address, 'tokentx', {
                            ...options,
                            contractAddress: USDT_CONTRACT
                        });
                        
                        await sleep(1000); // 1ç§’é—´éš”
                        
                        console.log(`ğŸ“¦ è·å–USDCä»£å¸äº¤æ˜“...`);
                        const usdcTokenTxList = await this.fetchTransactions(address, 'tokentx', {
                            ...options,
                            contractAddress: USDC_CONTRACT
                        });
                        
                        // åˆå¹¶USDTå’ŒUSDCäº¤æ˜“åˆ—è¡¨
                        const tokenTxList = [...usdtTokenTxList, ...usdcTokenTxList];
                        console.log(`ğŸ“Š ä»£å¸äº¤æ˜“ç»Ÿè®¡: USDT ${usdtTokenTxList.length}æ¡, USDC ${usdcTokenTxList.length}æ¡, æ€»è®¡ ${tokenTxList.length}æ¡`);
                        
                        // å¤„ç†å’Œåˆå¹¶äº¤æ˜“æ•°æ®
                        const processedData = this.processTransactions(address, normalTxList, internalTxList, tokenTxList, timeRange);
                        
                        console.log(`âœ… ${address.slice(0, 8)}... æ•°æ®è·å–å®Œæˆ: ${processedData.allTransactions.length}æ¡ç›¸å…³äº¤æ˜“`);
                        
                        return processedData;
                    } catch (error) {
                        console.error(`âŒ è·å–åœ°å€ ${address} æ•°æ®å¤±è´¥:`, error);
                        throw error;
                    }
                }
                
                /**
                 * å¤„ç†å’Œåˆå¹¶ä¸‰ç§ç±»å‹çš„äº¤æ˜“æ•°æ® - ä½¿ç”¨FastTransactionProcessorä¼˜åŒ–
                 * @param {string} address - åœ°å€
                 * @param {Array} normalTxList - æ™®é€šäº¤æ˜“
                 * @param {Array} internalTxList - å†…éƒ¨äº¤æ˜“
                 * @param {Array} tokenTxList - ä»£å¸äº¤æ˜“
                 * @param {Object} timeRange - æ—¶é—´èŒƒå›´
                 * @returns {Object} å¤„ç†åçš„äº¤æ˜“æ•°æ®
                 */
                static processTransactions(address, normalTxList, internalTxList, tokenTxList, timeRange) {
                    console.log(`ï¿½ï¿½ ä½¿ç”¨FastTransactionProcessorä¼˜åŒ–å¤„ç†...`);
                    
                    // ä½¿ç”¨æ–°çš„é«˜æ•ˆå¤„ç†å™¨
                    return FastTransactionProcessor.processAllTransactions(
                        address, 
                        normalTxList, 
                        internalTxList, 
                        tokenTxList, 
                        timeRange
                    );
                }
                
                /**
                 * åˆ¤æ–­äº¤æ˜“æ˜¯å¦ä¸USDTç›¸å…³
                 * @param {Object} tx - äº¤æ˜“å¯¹è±¡
                 * @param {string} address - ç›®æ ‡åœ°å€
                 * @returns {boolean} æ˜¯å¦ç›¸å…³
                 */
                static isUSDTRelatedTransaction(tx, address) {
                    // æ£€æŸ¥æ˜¯å¦ä¸ç›®æ ‡åœ°å€ç›¸å…³
                    if (tx.from?.toLowerCase() !== address && tx.to?.toLowerCase() !== address) {
                        return false;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯USDTåˆçº¦äº¤äº’
                    if (tx.to?.toLowerCase() === this.USDT_CONTRACT) {
                        return true;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯DEXäº¤æ˜“
                    if (tx.input && tx.input.length >= 10) {
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        const dexMethods = [
                            '0xa03de6a9', '0x7c025200', '0x84bd6d29', '0x12aa3caf',
                            '0xe5e8894b', '0x7ff36ab5', '0x38ed1739', '0x18cbafe5',
                            '0xe19c2253', '0x0d46641a'
                        ];
                        return dexMethods.includes(methodId);
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯DEXè·¯ç”±
                    return DEX_ROUTER_LIST.includes(tx.to?.toLowerCase());
                }
                
                /**
                 * æ‰¹é‡è·å–å¤šä¸ªåœ°å€çš„äº¤æ˜“æ•°æ®
                 * @param {Array} addressEntries - åœ°å€æ¡ç›®æ•°ç»„
                 * @param {Object} timeRange - æ—¶é—´èŒƒå›´
                 * @param {Function} progressCallback - è¿›åº¦å›è°ƒ
                 * @returns {Promise<Array>} å¤„ç†ç»“æœæ•°ç»„
                 */
                static async fetchMultipleAddressesData(addressEntries, timeRange, progressCallback = null) {
                    const results = [];
                    let completed = 0;
                    
                    console.log(`ğŸš€ å¼€å§‹æ‰¹é‡è·å– ${addressEntries.length} ä¸ªåœ°å€çš„æ•°æ®`);
                    
                    for (const entry of addressEntries) {
                        try {
                            console.log(`ğŸ“ [${completed + 1}/${addressEntries.length}] å¤„ç†: ${entry.name}`);
                            
                            const addressData = await this.fetchAddressData(entry.address, timeRange);
                            
                            results.push({
                                success: true,
                                entry,
                                data: addressData,
                                error: null
                            });
                            
                            completed++;
                            if (progressCallback) {
                                progressCallback(completed, addressEntries.length, entry.name);
                            }
                            
                            console.log(`âœ… ${entry.name}: å®Œæˆ (${addressData.stats.total}æ¡äº¤æ˜“)`);
                            
                            // åœ°å€é—´å»¶è¿Ÿ
                            if (completed < addressEntries.length) {
                                await sleep(2000); // 2ç§’å»¶è¿Ÿ
                            }
                            
                        } catch (error) {
                            console.error(`âŒ ${entry.name} å¤„ç†å¤±è´¥:`, error.message);
                            results.push({
                                success: false,
                                entry,
                                data: null,
                                error: error.message
                            });
                            
                            completed++;
                            if (progressCallback) {
                                progressCallback(completed, addressEntries.length, entry.name, error.message);
                            }
                        }
                    }
                    
                    const successCount = results.filter(r => r.success).length;
                    console.log(`ğŸ¯ æ‰¹é‡å¤„ç†å®Œæˆ: ${successCount}/${addressEntries.length} ä¸ªåœ°å€æˆåŠŸ`);
                    
                    return results;
                }

                /**
                 * è¶…é«˜æ•ˆçš„USDTæµå…¥æµå‡ºåˆ†æ - åŸºäºä½ çš„ApiUtilsä¼˜åŒ–
                 * @param {string} address - åœ°å€
                 * @param {Array} normalTxList - æ™®é€šäº¤æ˜“
                 * @param {Array} internalTxList - å†…éƒ¨äº¤æ˜“  
                 * @param {Array} tokenTxList - ä»£å¸äº¤æ˜“
                 * @param {Object} timeRange - æ—¶é—´èŒƒå›´
                 * @returns {Object} å¤„ç†åçš„äº¤æ˜“æ•°æ®
                 */
                static processTransactionsUltraFast(address, normalTxList, internalTxList, tokenTxList, timeRange) {
                    const addressLower = address.toLowerCase();
                    const usdtTransfers = [];
                    const relevantSwaps = [];
                    let totalUSDTIn = 0, totalUSDTOut = 0;
                    
                    console.log(`âš¡ è¶…é«˜æ•ˆå¤„ç†: ä»£å¸${tokenTxList.length}, æ™®é€š${normalTxList.length}, å†…éƒ¨${internalTxList.length}`);
                    
                    // 1. ä¼˜å…ˆå¤„ç†USDTä»£å¸è½¬è´¦ï¼ˆæœ€é‡è¦ï¼Œæœ€å¿«ï¼‰
                    for (const tx of tokenTxList) {
                        const time = parseInt(tx.timeStamp);
                        if (time >= timeRange.start && time < timeRange.end) {
                            if (tx.from?.toLowerCase() === addressLower || tx.to?.toLowerCase() === addressLower) {
                                // ç›´æ¥è®¡ç®—USDTæµå‘ï¼Œæ— éœ€é¢å¤–APIè°ƒç”¨
                                const amount = parseFloat(tx.value) / 1e18;
                                if (amount > 0) {
                                    tx.usdtAmount = amount;
                                    tx.isUSDTOut = tx.from?.toLowerCase() === addressLower;
                                    tx.isUSDTIn = tx.to?.toLowerCase() === addressLower;
                                    tx.txType = 'usdt_direct';
                                    
                                    if (tx.isUSDTOut) totalUSDTOut += amount;
                                    if (tx.isUSDTIn) totalUSDTIn += amount;
                                    
                                    usdtTransfers.push(tx);
                                }
                            }
                        }
                    }
                    
                    // 2. å¿«é€Ÿè¯†åˆ«ç›¸å…³swapäº¤æ˜“ï¼ˆåªå¤„ç†æ˜ç¡®çš„æ–¹æ³•IDï¼‰
                    const fastSwapMethods = {
                        '0xa03de6a9': 'PancakeSwap',
                        '0x7c025200': 'UniswapV3', 
                        '0xe5e8894b': '1inch',
                        '0x38ed1739': 'PancakeSwap',
                        '0x18cbafe5': 'PancakeSwap'
                    };
                    
                    for (const tx of normalTxList) {
                        const time = parseInt(tx.timeStamp);
                        if (time >= timeRange.start && time < timeRange.end) {
                            if (tx.from?.toLowerCase() === addressLower || tx.to?.toLowerCase() === addressLower) {
                                const methodId = tx.input?.slice(0, 10).toLowerCase();
                                if (fastSwapMethods[methodId]) {
                                    tx.txType = 'swap_potential';
                                    tx.dexName = fastSwapMethods[methodId];
                                    tx.needsReceipt = true; // æ ‡è®°éœ€è¦è¯¦ç»†åˆ†æ
                                    relevantSwaps.push(tx);
                                }
                            }
                        }
                    }
                    
                    console.log(`âš¡ å¿«é€Ÿè¯†åˆ«: USDTè½¬è´¦${usdtTransfers.length}æ¡, æ½œåœ¨Swap${relevantSwaps.length}æ¡`);
                    console.log(`ğŸ’° USDTæµå‘: æµå…¥${totalUSDTIn.toFixed(2)}, æµå‡º${totalUSDTOut.toFixed(2)}`);
                    
                    return {
                        usdtTransfers,
                        relevantSwaps,
                        totalUSDTIn,
                        totalUSDTOut,
                        needDetailAnalysis: relevantSwaps.length > 0,
                        stats: {
                            directUSDT: usdtTransfers.length,
                            potentialSwaps: relevantSwaps.length,
                            flowIn: totalUSDTIn,
                            flowOut: totalUSDTOut,
                            netFlow: totalUSDTIn - totalUSDTOut
                        }
                    };
                }
                
                /**
                 * æ£€æŸ¥æ˜¯å¦ä¸ºå¯èƒ½åŒ…å«USDTæµå‘çš„DEXäº¤æ˜“
                 * @param {Object} tx - äº¤æ˜“å¯¹è±¡
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 * @returns {boolean} æ˜¯å¦éœ€è¦è¿›ä¸€æ­¥åˆ†æ
                 */
                static isPotentialDEXTransaction(tx, userAddress) {
                    console.log(`ğŸ” æ£€æŸ¥æ˜¯å¦ä¸ºDEXäº¤æ˜“: ${tx.hash}`);
                    console.log(`   æ–¹æ³•ID: ${tx.input?.slice(0, 10)}`);
                    console.log(`   ç›®æ ‡åœ°å€: ${tx.to}`);
                    console.log(`   ç”¨æˆ·åœ°å€: ${userAddress}`);
                    console.log(`   from: ${tx.from}`);
                    
                    // ç‰¹åˆ«é’ˆå¯¹é—®é¢˜äº¤æ˜“çš„è°ƒè¯•
                    if (tx.hash === '0x65a753d80a95c83eac7b83139a88744f802dce45a3baea08e8d00587addf9a78') {
                        console.log(`ğŸ”¥ğŸ”¥ğŸ”¥ æ­£åœ¨åˆ†æé—®é¢˜äº¤æ˜“!`);
                        console.log(`   è¾“å…¥æ•°æ®: ${tx.input}`);
                        console.log(`   DEXè·¯ç”±åˆ—è¡¨é•¿åº¦: ${DEX_ROUTER_LIST.length}`);
                        console.log(`   toåœ°å€æ˜¯å¦åœ¨DEXåˆ—è¡¨ä¸­: ${DEX_ROUTER_LIST.includes(tx.to?.toLowerCase())}`);
                        if (tx.input && tx.input.length > 10) {
                            const methodId = tx.input.slice(0, 10).toLowerCase();
                            console.log(`   æå–çš„æ–¹æ³•ID: ${methodId}`);
                            console.log(`   æ˜¯å¦åŒ¹é…0xa03de6a9: ${methodId === '0xa03de6a9'}`);
                        }
                    }
                    
                    // 1. æ£€æŸ¥æ˜¯å¦æ¶‰åŠç”¨æˆ·åœ°å€
                    if (tx.from?.toLowerCase() !== userAddress && tx.to?.toLowerCase() !== userAddress) {
                        console.log(`   âŒ ä¸æ¶‰åŠç”¨æˆ·åœ°å€`);
                        return false;
                    }
                    
                    // 2. æ£€æŸ¥æ˜¯å¦æ¶‰åŠå·²çŸ¥çš„DEXè·¯ç”±
                    if (DEX_ROUTER_LIST.includes(tx.to?.toLowerCase())) {
                        console.log(`ğŸ¯ æ£€æµ‹åˆ°DEXè·¯ç”±äº¤æ˜“: ${tx.hash} -> ${tx.to}`);
                        return true;
                    }
                    
                    // 3. æ£€æŸ¥æ–¹æ³•IDæ˜¯å¦ä¸ºDEXç›¸å…³
                    if (tx.input && tx.input.length > 10) {
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        const dexMethods = [
                            '0xa03de6a9', // swapExactTokensForTokens
                            '0x7c025200', // swapExactETHForTokens  
                            '0x84bd6d29', // swapExactTokensForETH
                            '0x12aa3caf', // swapExactTokensForTokensSupportingFeeOnTransferTokens
                            '0xe5e8894b', // swapExactTokensForETHSupportingFeeOnTransferTokens
                            '0x7ff36ab5', // swapExactETHForTokensSupportingFeeOnTransferTokens
                            '0x38ed1739', // swapExactTokensForTokens
                            '0x18cbafe5', // swapExactTokensForETH
                            '0xf305d719', // addLiquidityETH
                            '0xe8e33700', // addLiquidity
                            '0x02751cec', // removeLiquidity
                            '0xaf2979eb'  // removeLiquidityETH
                        ];
                        
                        if (dexMethods.includes(methodId)) {
                            console.log(`ğŸ¯ æ£€æµ‹åˆ°DEXæ–¹æ³•: ${tx.hash} -> ${methodId}`);
                            if (methodId === '0xa03de6a9') {
                                console.log(`ğŸ”¥ ç‰¹åˆ«æ³¨æ„: è¿™æ˜¯callOneInchæ–¹æ³• ${tx.hash}`);
                            }
                            return true;
                        }
                    }
                    
                    // 4. æ£€æŸ¥Gasä½¿ç”¨é‡ï¼ˆDEXäº¤æ˜“é€šå¸¸æ¶ˆè€—æ›´å¤šGasï¼‰
                    const gasUsed = parseFloat(tx.gasUsed || '0');
                    if (gasUsed > 100000) { // è¶…è¿‡10ä¸‡Gas
                        console.log(`ğŸ¯ æ£€æµ‹åˆ°é«˜Gasäº¤æ˜“: ${tx.hash} -> ${gasUsed} gas`);
                        return true;
                    }
                    
                    return false;
                }
                
                /**
                 * åˆ†æäº¤æ˜“receiptä»¥æå–USDTæµå‘ä¿¡æ¯
                 * @param {Array} transactions - éœ€è¦åˆ†æçš„äº¤æ˜“åˆ—è¡¨
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 */
                static async analyzeReceiptsForUSDTFlow(transactions, userAddress) {
                    console.log(`ğŸ” å¼€å§‹åˆ†æ${transactions.length}ä¸ªäº¤æ˜“çš„receipt...`);
                    console.log(`ğŸ“‹ è¦åˆ†æçš„äº¤æ˜“å“ˆå¸Œ:`, transactions.map(tx => tx.hash));
                    
                    const batchSize = 3; // æ‰¹é‡å¤„ç†é¿å…APIé™åˆ¶
                    for (let i = 0; i < transactions.length; i += batchSize) {
                        const batch = transactions.slice(i, i + batchSize);
                        console.log(`ğŸ“¦ å¤„ç†receiptæ‰¹æ¬¡: ${i+1}-${Math.min(i+batchSize, transactions.length)}/${transactions.length}`);
                        
                        // å¹¶è¡Œè·å–è¿™ä¸€æ‰¹çš„receipt
                        const receiptPromises = batch.map(async tx => {
                            try {
                                console.log(`ğŸ“¦ è·å–receipt: ${tx.hash}`);
                                await sleep(200); // 200mså»¶è¿Ÿé¿å…APIé™åˆ¶
                                const receipt = await getTxReceipt(tx.hash);
                                console.log(`âœ… è·å–receiptæˆåŠŸ: ${tx.hash}, logsæ•°é‡: ${receipt?.logs?.length || 0}`);
                                return { tx, receipt };
                            } catch (e) {
                                console.warn(`âš ï¸ è·å–receiptå¤±è´¥: ${tx.hash.slice(0, 10)}...`);
                                return { tx, receipt: null };
                            }
                        });
                        
                        const receiptResults = await Promise.all(receiptPromises);
                        
                        // åˆ†æreceiptä¸­çš„USDTæµå‘
                        for (const { tx, receipt } of receiptResults) {
                            if (receipt && receipt.logs) {
                                this.extractUSDTFlowFromReceipt(tx, receipt, userAddress);
                            }
                        }
                        
                        // æ‰¹æ¬¡é—´å»¶è¿Ÿ
                        if (i + batchSize < transactions.length) {
                            await sleep(500);
                        }
                    }
                    
                    console.log(`âœ… Receiptåˆ†æå®Œæˆ`);
                }
                
                /**
                 * ä»receiptçš„logsä¸­æå–USDTæµå‘ä¿¡æ¯
                 * @param {Object} tx - äº¤æ˜“å¯¹è±¡
                 * @param {Object} receipt - äº¤æ˜“receipt
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 */
                static extractUSDTFlowFromReceipt(tx, receipt, userAddress) {
                    console.log(`ğŸ” åˆ†æç¨³å®šå¸æµå‘: ${tx.hash}`);
                    console.log(`   ç”¨æˆ·åœ°å€: ${userAddress}`);
                    console.log(`   Receipt logsæ•°é‡: ${receipt?.logs?.length || 0}`);
                    
                    const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                    
                    // æŸ¥æ‰¾æ‰€æœ‰ç¨³å®šå¸è½¬è´¦äº‹ä»¶
                    const stablecoinTransfers = receipt.logs.filter(log => 
                        STABLECOIN_CONTRACTS.includes(log.address.toLowerCase()) && 
                        log.topics[0] === ERC20_TRANSFER_TOPIC
                    );
                    
                    console.log(`ğŸ” å‘ç°${stablecoinTransfers.length}ä¸ªç¨³å®šå¸è½¬è´¦äº‹ä»¶`);
                    
                    for (const log of stablecoinTransfers) {
                        try {
                            const from = '0x' + log.topics[1].slice(26).toLowerCase();
                            const to = '0x' + log.topics[2].slice(26).toLowerCase();
                            const amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                            
                            // è¯†åˆ«ç¨³å®šå¸ç±»å‹
                            let coinSymbol = 'Unknown';
                            if (log.address.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                                coinSymbol = 'USDT';
                            } else if (log.address.toLowerCase() === USDC_CONTRACT.toLowerCase()) {
                                coinSymbol = 'USDC';
                            }
                            
                            console.log(`ğŸ” ${coinSymbol} Transfer: ${from.slice(0, 8)}... -> ${to.slice(0, 8)}... : ${amount} ${coinSymbol}`);
                            
                            // æ£€æŸ¥æ˜¯å¦ä¸ç”¨æˆ·ç›¸å…³
                            if (from === userAddress.toLowerCase() || to === userAddress.toLowerCase()) {
                                // ç¡®ä¿tokenå­˜åœ¨
                                if (!tx.tokens[coinSymbol]) {
                                    tx.tokens[coinSymbol] = { inflow: 0, outflow: 0, address: log.address };
                                }
                                
                                if (from === userAddress.toLowerCase()) {
                                    tx.tokens[coinSymbol].outflow += amount;
                                    console.log(`  ğŸ“¤ ç”¨æˆ·${coinSymbol}æµå‡º: ${amount} ${coinSymbol}`);
                                }
                                if (to === userAddress.toLowerCase()) {
                                    tx.tokens[coinSymbol].inflow += amount;
                                    console.log(`  ğŸ“¥ ç”¨æˆ·${coinSymbol}æµå…¥: ${amount} ${coinSymbol}`);
                                }
                            }
                        } catch (e) {
                            console.warn(`âš ï¸ è§£æTransferäº‹ä»¶å¤±è´¥:`, e);
                        }
                    }
                }
            }

            // æ–°çš„äº¤æ˜“æ•°æ®åˆ†æå‡½æ•° - å¤„ç†ApiUtilsè¿”å›çš„æ•°æ®
            async function analyzeTransactionData(addressInfo, transactionData, timeRange, usdtPrice, bnbPrice, usdtBalance) {
                console.log(`ğŸ” å¼€å§‹åˆ†æ ${addressInfo.name} çš„äº¤æ˜“æ•°æ®`);
                console.log(`ğŸ“Š æ•°æ®ç»Ÿè®¡:`, transactionData.stats);
                
                // åˆ¤æ–­æ˜¯å¦ä¸ºæ™®é€šUSDTè½¬è´¦ï¼ˆä¸åº”è®¡å…¥ä¹°å–ç»Ÿè®¡ï¼‰
                function isSimpleUSDTTransfer(tx) {
                    // 1. æ£€æŸ¥æ˜¯å¦æ¶‰åŠDEXè·¯ç”±
                    if (DEX_ROUTER_LIST.includes(tx.to?.toLowerCase()) || 
                        DEX_ROUTER_LIST.includes(tx.from?.toLowerCase())) {
                        return false; // æ¶‰åŠDEXï¼Œæ˜¯äº¤æ˜“
                    }
                    
                    // 2. æ£€æŸ¥inputæ˜¯å¦ä¸ºå¤æ‚è°ƒç”¨
                    if (tx.input && tx.input.length > 10) {
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        // å¸¸è§çš„swapæ–¹æ³•ID
                        const swapMethods = [
                            '0xa03de6a9', '0x7c025200', '0x84bd6d29', '0x12aa3caf',
                            '0xe5e8894b', '0x7ff36ab5', '0x38ed1739', '0x18cbafe5'
                        ];
                        if (swapMethods.includes(methodId)) {
                            return false; // æ˜¯swapæ–¹æ³•ï¼Œæ˜¯äº¤æ˜“
                        }
                        
                        // USDTçš„transferæ–¹æ³•ID
                        if (methodId === '0xa9059cbb') {
                            return true; // æ˜¯æ™®é€štransferï¼Œæ˜¯è½¬è´¦
                        }
                    }
                    
                    // 3. å¦‚æœtoåœ°å€æ˜¯USDTåˆçº¦ï¼Œä¸”æ˜¯ç®€å•è°ƒç”¨ï¼Œå¯èƒ½æ˜¯æ™®é€šè½¬è´¦
                    if (tx.to?.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                        return true;
                    }
                    
                    // 4. å…¶ä»–æƒ…å†µè§†ä¸ºå¯èƒ½çš„äº¤æ˜“
                    return false;
                }
                
                const address = addressInfo.address.toLowerCase();
                const trades = [];
                const unknownTrades = [];
                let totalBuy = 0, totalSell = 0, totalGasCost = 0;
                
                // ç¡®ä¿bnbPriceæ˜¯æœ‰æ•ˆçš„æ•°å­—
                if (isNaN(bnbPrice) || bnbPrice <= 0) {
                    console.warn(`æ£€æµ‹åˆ°æ— æ•ˆçš„BNBä»·æ ¼: ${bnbPrice}ï¼Œä½¿ç”¨é»˜è®¤ä»·æ ¼660`);
                    bnbPrice = 660;
                }
                
                // æŒ‰äº¤æ˜“ç±»å‹åˆ†åˆ«å¤„ç†
                console.log(`ğŸš€ å¼€å§‹åˆ†æ ${transactionData.allTransactions.length} æ¡äº¤æ˜“...`);
                
                // éœ€è¦è·å–Receiptçš„äº¤æ˜“
                const needReceiptTxs = [];
                
                console.log(`â›½ ç›´æ¥ä»äº¤æ˜“è®°å½•è®¡ç®—Gasè´¹ç”¨ï¼ˆæ— éœ€é¢å¤–APIè°ƒç”¨ï¼‰...`);
                
                // ç›´æ¥ä»äº¤æ˜“è®°å½•æ‰¹é‡è®¡ç®—Gasè´¹ç”¨
                const gasCostMap = GasUtils.batchCalculateGasFromTx(transactionData.allTransactions);
                
                for (const tx of transactionData.allTransactions) {
                    const time = parseInt(tx.timeStamp);
                    const realGasCost = gasCostMap.get(tx.hash) || GasEstimator.estimateGasCost('token_transfer');
                    
                    if (tx.txType === 'usdt_transfer') {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºæ™®é€šè½¬è´¦ï¼ˆä¸ç»Ÿè®¡ï¼‰è¿˜æ˜¯äº¤æ˜“ä¹°å–ï¼ˆç»Ÿè®¡ï¼‰
                        console.log(`ğŸ’° æ£€æŸ¥USDTè½¬è´¦ç±»å‹: ${tx.hash}`);
                        
                        // åˆ¤æ–­æ˜¯å¦æ˜¯æ™®é€šè½¬è´¦çš„æ¡ä»¶ï¼š
                        // 1. æ²¡æœ‰å¤æ‚çš„inputï¼ˆæ™®é€šè½¬è´¦é€šå¸¸inputå¾ˆç®€å•ï¼‰
                        // 2. ä¸æ¶‰åŠDEXè·¯ç”±
                        // 3. ä¸æ˜¯swapç›¸å…³çš„æ–¹æ³•
                        const isSimpleTransfer = isSimpleUSDTTransfer(tx);
                        
                        if (isSimpleTransfer) {
                            console.log(`ğŸ“¤ è·³è¿‡æ™®é€šUSDTè½¬è´¦ï¼ˆä¸è®¡å…¥ç»Ÿè®¡ï¼‰: ${tx.hash}`);
                            // è®°å½•ä¸ºæ™®é€šè½¬è´¦ï¼Œä½†ä¸è®¡å…¥ä¹°å–ç»Ÿè®¡
                            unknownTrades.push({
                                hash: tx.hash,
                                timestamp: tx.timeStamp,
                                methodId: 'simple_transfer',
                                gasCost: realGasCost,
                                tokenAddress: USDT_CONTRACT,
                                note: 'æ™®é€šUSDTè½¬è´¦ï¼ˆæœªè®¡å…¥ä¹°å–ç»Ÿè®¡ï¼‰'
                            });
                            continue;
                        }
                        
                        // å¦‚æœä¸æ˜¯æ™®é€šè½¬è´¦ï¼ŒæŒ‰åŸé€»è¾‘å¤„ç†
                        let amount = 0;
                        
                        // é¦–å…ˆå°è¯•ä»tx.valueè§£æ
                        if (tx.value && tx.value !== '0') {
                            amount = parseFloat(tx.value) / 1e18;
                        } else {
                            // éœ€è¦ä»Receiptè·å–
                            needReceiptTxs.push({tx, realGasCost});
                            continue;
                        }
                        
                        if (amount <= 0) {
                            console.log(`âš ï¸ è·³è¿‡æ— æ•ˆé‡‘é¢çš„USDTäº¤æ˜“: ${tx.hash}, é‡‘é¢: ${amount}`);
                            continue;
                        }
                        
                        let trade = null;
                        if (tx.from?.toLowerCase() === address) {
                            // USDTæµå‡º = ä¹°å…¥å…¶ä»–ä»£å¸
                            trade = {
                                hash: tx.hash,
                                usdtAmount: -amount,
                                tokenAmount: 0,
                                tokenAddress: USDT_CONTRACT,
                                isBuy: true,
                                isSell: false,
                                timestamp: time,
                                gasCost: realGasCost
                            };
                            totalBuy += amount;
                            console.log(`âœ… USDTäº¤æ˜“-ä¹°å…¥: ${amount.toFixed(4)} USDT, Gas: ${realGasCost.toFixed(6)} BNB`);
                        } else if (tx.to?.toLowerCase() === address) {
                            // USDTæµå…¥ = å–å‡ºå…¶ä»–ä»£å¸
                            trade = {
                                hash: tx.hash,
                                usdtAmount: amount,
                                tokenAmount: 0,
                                tokenAddress: USDT_CONTRACT,
                                isBuy: false,
                                isSell: true,
                                timestamp: time,
                                gasCost: realGasCost
                            };
                            totalSell += amount;
                            console.log(`âœ… USDTäº¤æ˜“-å–å‡º: ${amount.toFixed(4)} USDT, Gas: ${realGasCost.toFixed(6)} BNB`);
                        }
                        
                        if (trade) {
                            trades.push(trade);
                            totalGasCost += trade.gasCost;
                        }
                        
                    } else if (tx.txType === 'normal_relevant') {
                        // ç›¸å…³çš„æ™®é€šäº¤æ˜“ï¼ˆå¯èƒ½æ˜¯swapç­‰ï¼‰
                        console.log(`ğŸ”„ å¤„ç†ç›¸å…³äº¤æ˜“: ${tx.hash}, æ–¹æ³•: ${tx.input?.slice(0, 10)}`);
                        needReceiptTxs.push({tx, realGasCost});
                        
                    } else if (tx.txType === 'internal') {
                        // å†…éƒ¨äº¤æ˜“
                        console.log(`ğŸ  å¤„ç†å†…éƒ¨äº¤æ˜“: ${tx.hash}`);
                        // å†…éƒ¨äº¤æ˜“é€šå¸¸ä¸ç›´æ¥æ¶‰åŠUSDTï¼Œä½†å¯èƒ½æœ‰ETH/BNBæµåŠ¨
                        unknownTrades.push({
                            hash: tx.hash,
                            timestamp: tx.timeStamp,
                            methodId: 'internal',
                            gasCost: realGasCost, // ä½¿ç”¨çœŸå®Gasè´¹ç”¨
                            tokenAddress: ''
                        });
                    }
                }
                
                // æ‰¹é‡å¤„ç†éœ€è¦Receiptçš„äº¤æ˜“
                if (needReceiptTxs.length > 0) {
                    console.log(`ğŸ“¦ æ‰¹é‡å¤„ç† ${needReceiptTxs.length} ä¸ªéœ€è¦Receiptçš„äº¤æ˜“...`);
                    
                    const txHashes = needReceiptTxs.map(item => item.tx.hash);
                    const receiptResults = await batchGetTxReceipts(txHashes);
                    
                    for (let i = 0; i < needReceiptTxs.length; i++) {
                        const {tx, realGasCost} = needReceiptTxs[i];
                        const { receipt } = receiptResults[i];
                        const time = parseInt(tx.timeStamp);
                        
                        if (!receipt) {
                            console.log(`âš ï¸ è·³è¿‡æ— Receiptçš„äº¤æ˜“: ${tx.hash}`);
                            unknownTrades.push({
                                hash: tx.hash,
                                timestamp: tx.timeStamp,
                                methodId: tx.input?.slice(0, 10) || 'unknown',
                                gasCost: realGasCost, // ä½¿ç”¨çœŸå®Gasè´¹ç”¨
                                tokenAddress: tx.contractAddress || ''
                            });
                            continue;
                        }
                        
                        // è§£æUSDT Transferäº‹ä»¶
                        const transferInfo = parseUSDTTransferFromReceipt(receipt, addressInfo.address);
                        
                        if (transferInfo && transferInfo.amount > 0) {
                            let trade = null;
                            if (transferInfo.isOutgoing) {
                                // USDTæµå‡º = ä¹°å…¥
                                trade = {
                                    hash: tx.hash,
                                    usdtAmount: -transferInfo.amount,
                                    tokenAmount: 0,
                                    tokenAddress: USDT_CONTRACT,
                                    isBuy: true,
                                    isSell: false,
                                    timestamp: time,
                                    gasCost: realGasCost // ä½¿ç”¨çœŸå®Gasè´¹ç”¨
                                };
                                totalBuy += transferInfo.amount;
                                console.log(`âœ… Receiptè§£æ-USDTæµå‡º(ä¹°å…¥): ${transferInfo.amount.toFixed(4)} USDT, Gas: ${realGasCost.toFixed(6)} BNB`);
                            } else if (transferInfo.isIncoming) {
                                // USDTæµå…¥ = å–å‡º
                                trade = {
                                    hash: tx.hash,
                                    usdtAmount: transferInfo.amount,
                                    tokenAmount: 0,
                                    tokenAddress: USDT_CONTRACT,
                                    isBuy: false,
                                    isSell: true,
                                    timestamp: time,
                                    gasCost: realGasCost // ä½¿ç”¨çœŸå®Gasè´¹ç”¨
                                };
                                totalSell += transferInfo.amount;
                                console.log(`âœ… Receiptè§£æ-USDTæµå…¥(å–å‡º): ${transferInfo.amount.toFixed(4)} USDT, Gas: ${realGasCost.toFixed(6)} BNB`);
                            }
                            
                            if (trade) {
                                trades.push(trade);
                                totalGasCost += trade.gasCost;
                            }
                        } else {
                            // æ— æ³•è§£æçš„äº¤æ˜“
                            unknownTrades.push({
                                hash: tx.hash,
                                timestamp: tx.timeStamp,
                                methodId: tx.input?.slice(0, 10) || 'unknown',
                                gasCost: realGasCost, // ä½¿ç”¨çœŸå®Gasè´¹ç”¨
                                tokenAddress: tx.contractAddress || ''
                            });
                            console.log(`âš ï¸ æ— æ³•è§£æTransferäº‹ä»¶: ${tx.hash}`);
                        }
                    }
                }
                
                // è®¡ç®—æœ€ç»ˆç»“æœ
                const gasCostInUSDT = totalGasCost * bnbPrice;
                const profitLoss = totalSell - totalBuy;
                const netProfitLoss = profitLoss - gasCostInUSDT;
                
                // è¯¦ç»†çš„åˆ†ææ‘˜è¦
                console.log(`ğŸ“‹ ${addressInfo.name} è¯¦ç»†æ‘˜è¦:`);
                console.log(`   ğŸ“¦ æ€»äº¤æ˜“æ•°: ${transactionData.allTransactions.length}`);
                console.log(`   âœ… å·²è¯†åˆ«äº¤æ˜“: ${trades.length}`);
                console.log(`   â“ æœªè¯†åˆ«äº¤æ˜“: ${unknownTrades.length}`);
                console.log(`   ğŸ’° USDTæµå‡º(ä¹°å…¥): ${trades.filter(t => t.isBuy).length}æ¬¡ï¼Œæ€»é¢: ${totalBuy.toFixed(2)} USDT`);
                console.log(`   ğŸ’¸ USDTæµå…¥(å–å‡º): ${trades.filter(t => t.isSell).length}æ¬¡ï¼Œæ€»é¢: ${totalSell.toFixed(2)} USDT`);
                console.log(`   ğŸ“ˆ å‡€ç›ˆäº: ${profitLoss.toFixed(2)} USDT (æ‰£é™¤Gaså‰)`);
                console.log(`   ğŸ“‰ å®é™…ç›ˆäº: ${netProfitLoss.toFixed(2)} USDT (æ‰£é™¤Gaså)`);
                
                return {
                    name: addressInfo.name,
                    address: addressInfo.address,
                    trades,
                    unknownTrades,
                    totalBuyValue: totalBuy,
                    totalSellValue: totalSell,
                    profitLoss: profitLoss,
                    netProfitLoss: netProfitLoss,
                    totalGasCost: totalGasCost,
                    gasCostInUSDT: gasCostInUSDT,
                    bnbPrice: bnbPrice,
                    usdtPrice: usdtPrice,
                    usdtBalance: parseFloat(usdtBalance),
                    timeRange,
                    stats: transactionData.stats
                };
            }

            // è®¡ç®—çœŸå®Gasè´¹ç”¨çš„å‡½æ•°
            async function calculateRealGasCost(txHash, txType = 'token_transfer') {
                try {
                    // å¹¶è¡Œè·å–äº¤æ˜“è¯¦æƒ…å’ŒReceipt
                    const [txDetail, receipt] = await Promise.all([
                        getTxDetail(txHash),
                        getTxReceipt(txHash)
                    ]);
                    
                    if (receipt && txDetail) {
                        const gasUsed = parseInt(receipt.gasUsed, 16);
                        const gasPrice = parseInt(txDetail.gasPrice, 16);
                        const gasCost = gasUsed * gasPrice / 1e18;
                        
                        console.log(`ğŸ’° ${txHash.slice(0, 10)}... Gasè´¹ç”¨: ${gasUsed} Ã— ${(gasPrice/1e9).toFixed(2)}Gwei = ${gasCost.toFixed(6)} BNB`);
                        return gasCost;
                    } else {
                        console.warn(`âš ï¸ æ— æ³•è·å–Gasä¿¡æ¯: ${txHash.slice(0, 10)}...ï¼Œä½¿ç”¨ä¼°ç®—å€¼`);
                        return GasEstimator.estimateGasCost(txType); // ä½¿ç”¨åŠ¨æ€ä¼°ç®—
                    }
                } catch (e) {
                    console.warn(`âš ï¸ è®¡ç®—Gasè´¹ç”¨å¤±è´¥: ${txHash.slice(0, 10)}...`, e.message);
                    return GasEstimator.estimateGasCost(txType); // ä½¿ç”¨åŠ¨æ€ä¼°ç®—
                }
            }
            
            // æ‰¹é‡è®¡ç®—Gasè´¹ç”¨
            async function batchCalculateGasCosts(txHashes, txTypes = []) {
                const results = [];
                const batchSize = 3; // å‡å°‘æ‰¹æ¬¡å¤§å°é¿å…APIé™åˆ¶
                
                for (let i = 0; i < txHashes.length; i += batchSize) {
                    const batch = txHashes.slice(i, i + batchSize);
                    const batchTypes = txTypes.slice(i, i + batchSize);
                    console.log(`ğŸ’° æ‰¹é‡è®¡ç®—Gasè´¹ç”¨: ${i+1}-${Math.min(i+batchSize, txHashes.length)}/${txHashes.length}`);
                    
                    const batchPromises = batch.map((hash, index) => 
                        calculateRealGasCost(hash, batchTypes[index] || 'token_transfer')
                    );
                    const batchResults = await Promise.all(batchPromises);
                    results.push(...batchResults);
                    
                    // æ‰¹æ¬¡é—´å»¶è¿Ÿ
                    if (i + batchSize < txHashes.length) {
                        await sleep(800); // ç¨å¾®å¢åŠ å»¶è¿Ÿ
                    }
                }
                
                return results;
            }

            // åŠ¨æ€Gasè´¹ç”¨ä¼°ç®—å™¨
            class GasEstimator {
                static DEFAULT_GAS_PRICE = 5e9; // 5 Gwei
                static SIMPLE_TRANSFER_GAS = 21000;
                static TOKEN_TRANSFER_GAS = 65000;
                static SWAP_GAS = 150000;
                static COMPLEX_GAS = 300000;
                
                /**
                 * æ ¹æ®äº¤æ˜“ç±»å‹ä¼°ç®—Gasè´¹ç”¨
                 * @param {string} txType - äº¤æ˜“ç±»å‹
                 * @param {number} gasPrice - Gasä»·æ ¼(wei)ï¼Œå¯é€‰
                 * @returns {number} ä¼°ç®—çš„Gasè´¹ç”¨(BNB)
                 */
                static estimateGasCost(txType = 'token_transfer', gasPrice = null) {
                    const price = gasPrice || this.DEFAULT_GAS_PRICE;
                    let gasLimit;
                    
                    switch (txType) {
                        case 'simple_transfer':
                            gasLimit = this.SIMPLE_TRANSFER_GAS;
                            break;
                        case 'token_transfer':
                            gasLimit = this.TOKEN_TRANSFER_GAS;
                            break;
                        case 'swap':
                            gasLimit = this.SWAP_GAS;
                            break;
                        case 'complex':
                            gasLimit = this.COMPLEX_GAS;
                            break;
                        default:
                            gasLimit = this.TOKEN_TRANSFER_GAS;
                    }
                    
                    const estimatedCost = gasLimit * price / 1e18;
                    console.log(`â›½ Gasä¼°ç®— [${txType}]: ${gasLimit} Ã— ${(price/1e9).toFixed(1)}Gwei = ${estimatedCost.toFixed(6)} BNB`);
                    return estimatedCost;
                }
                
                /**
                 * è·å–å½“å‰ç½‘ç»œGasä»·æ ¼ï¼ˆç®€åŒ–ç‰ˆï¼‰
                 * @returns {Promise<number>} Gasä»·æ ¼(wei)
                 */
                static async getCurrentGasPrice() {
                    try {
                        // è¿™é‡Œå¯ä»¥è°ƒç”¨BSCçš„APIè·å–å®æ—¶gasä»·æ ¼
                        // æš‚æ—¶ä½¿ç”¨å›ºå®šå€¼ï¼Œä½†ä¸ç¡¬ç¼–ç åœ¨ä¸šåŠ¡é€»è¾‘ä¸­
                        const estimatedGasPrice = 5e9; // 5 Gwei
                        console.log(`â›½ å½“å‰ä¼°ç®—Gasä»·æ ¼: ${(estimatedGasPrice/1e9).toFixed(1)} Gwei`);
                        return estimatedGasPrice;
                    } catch (e) {
                        console.warn(`âš ï¸ è·å–Gasä»·æ ¼å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
                        return this.DEFAULT_GAS_PRICE;
                    }
                }
            }

            // Gasè´¹ç”¨å·¥å…·ç±» - ç›´æ¥ä»äº¤æ˜“è®°å½•æå–
            class GasUtils {
                /**
                 * ä»äº¤æ˜“è®°å½•ç›´æ¥è®¡ç®—gasè´¹ç”¨
                 * @param {Object} tx - äº¤æ˜“è®°å½•
                 * @returns {number} Gasè´¹ç”¨(BNB)
                 */
                static calculateGasFromTx(tx) {
                    try {
                        if (tx.gasUsed && tx.gasPrice) {
                            // ç›´æ¥ä»äº¤æ˜“è®°å½•è®¡ç®—ï¼Œæ— éœ€é¢å¤–APIè°ƒç”¨
                            const gasUsed = parseFloat(tx.gasUsed);
                            const gasPrice = parseFloat(tx.gasPrice);
                            const gasFee = (gasUsed * gasPrice) / 1e18; // è½¬æ¢ä¸ºBNB
                            
                            console.log(`â›½ ä»äº¤æ˜“è®°å½•è®¡ç®—Gas: ${gasUsed} Ã— ${(gasPrice/1e9).toFixed(2)}Gwei = ${gasFee.toFixed(6)} BNB`);
                            return gasFee;
                        } else {
                            console.log(`âš ï¸ äº¤æ˜“è®°å½•ç¼ºå°‘gasä¿¡æ¯: ${tx.hash?.slice(0, 10)}...`);
                            return GasEstimator.estimateGasCost('token_transfer');
                        }
                    } catch (e) {
                        console.warn(`âš ï¸ è®¡ç®—Gasè´¹ç”¨å¤±è´¥: ${tx.hash?.slice(0, 10)}...`, e.message);
                        return GasEstimator.estimateGasCost('token_transfer');
                    }
                }
                
                /**
                 * æ‰¹é‡è®¡ç®—äº¤æ˜“çš„gasè´¹ç”¨
                 * @param {Array} transactions - äº¤æ˜“åˆ—è¡¨
                 * @returns {Map} hashåˆ°gasè´¹ç”¨çš„æ˜ å°„
                 */
                static batchCalculateGasFromTx(transactions) {
                    const gasCostMap = new Map();
                    
                    console.log(`â›½ æ‰¹é‡ä»äº¤æ˜“è®°å½•è®¡ç®— ${transactions.length} æ¡äº¤æ˜“çš„Gasè´¹ç”¨...`);
                    
                    for (const tx of transactions) {
                        const gasCost = this.calculateGasFromTx(tx);
                        gasCostMap.set(tx.hash, gasCost);
                    }
                    
                    console.log(`âœ… æ‰¹é‡Gasè®¡ç®—å®Œæˆ: ${gasCostMap.size} æ¡è®°å½•`);
                    return gasCostMap;
                }
                
                /**
                 * ç»Ÿè®¡æ€»gasæ¶ˆè€—
                 * @param {Array} transactions - äº¤æ˜“åˆ—è¡¨
                 * @returns {number} æ€»gasè´¹ç”¨(BNB)
                 */
                static calculateTotalGas(transactions) {
                    let totalGas = 0;
                    
                    for (const tx of transactions) {
                        totalGas += this.calculateGasFromTx(tx);
                    }
                    
                    return totalGas;
                }
            }

            // é«˜æ•ˆäº¤æ˜“å¤„ç†å™¨ - å‚è€ƒç”¨æˆ·çš„ä¼˜åŒ–æ–¹æ¡ˆ
            class FastTransactionProcessor {
                /**
                 * é«˜æ•ˆå¤„ç†å’Œåˆå¹¶äº¤æ˜“æ•°æ®ï¼ˆå‚è€ƒalpha.dogæ–¹å¼ï¼‰
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 * @param {Array} normalTxList - æ™®é€šäº¤æ˜“åˆ—è¡¨
                 * @param {Array} internalTxList - å†…éƒ¨äº¤æ˜“åˆ—è¡¨  
                 * @param {Array} tokenTxList - ä»£å¸äº¤æ˜“åˆ—è¡¨
                 * @param {Object} timeRange - æ—¶é—´èŒƒå›´
                 * @returns {Object} å¤„ç†åçš„äº¤æ˜“æ•°æ®
                 */
                static processAllTransactions(userAddress, normalTxList, internalTxList, tokenTxList, timeRange) {
                    console.log(`âš¡ å¿«é€Ÿå¤„ç†: æ™®é€š${normalTxList.length}, å†…éƒ¨${internalTxList.length}, ä»£å¸${tokenTxList.length}`);
                    
                    // ä½¿ç”¨Mapè¿›è¡Œé«˜æ•ˆçš„å“ˆå¸ŒæŸ¥æ‰¾
                    const txMap = new Map();
                    const addressLower = userAddress.toLowerCase();
                    
                    // 1. å¤„ç†æ™®é€šäº¤æ˜“ - æå–åŸºç¡€ä¿¡æ¯å’ŒBNBæµå‘
                    normalTxList.forEach(tx => {
                        const time = parseInt(tx.timeStamp);
                        if (time < timeRange.start || time >= timeRange.end) return;
                        
                        const tokens = new Map();
                        
                        // è®¡ç®—BNBæµå…¥/æµå‡º
                        if (tx.value && parseFloat(tx.value) > 0) {
                            const bnbValue = parseFloat(tx.value) / 1e18;
                            tokens.set('BNB', {
                                inflow: tx.to?.toLowerCase() === addressLower ? bnbValue : 0,
                                outflow: tx.from?.toLowerCase() === addressLower ? bnbValue : 0
                            });
                        }
                        
                        // ğŸš€ æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦å¯èƒ½åŒ…å«USDTæµå‘çš„DEXäº¤æ˜“
                        const isPotentialDEXTx = this.isPotentialDEXTransaction(tx, addressLower);
                        
                        // ç›´æ¥ä»äº¤æ˜“è®°å½•è®¡ç®—çœŸå®gasè´¹ç”¨ - å…³é”®ä¼˜åŒ–ï¼
                        const gasFee = tx.gasUsed && tx.gasPrice ? 
                            (parseFloat(tx.gasUsed) * parseFloat(tx.gasPrice)) / 1e18 : 0;
                        
                        txMap.set(tx.hash, {
                            hash: tx.hash,
                            timeStamp: tx.timeStamp,
                            from: tx.from,
                            to: tx.to,
                            value: tx.value,
                            gasPrice: tx.gasPrice,
                            gasUsed: tx.gasUsed,
                            input: tx.input,
                            status: tx.isError === '0' ? 'æˆåŠŸ' : 'å¤±è´¥',
                            tokens: tokens,
                            gasFee: gasFee,
                            txType: 'normal',
                            needsReceiptAnalysis: isPotentialDEXTx // ğŸš€ æ ‡è®°éœ€è¦receiptåˆ†æ
                        });
                    });
                    
                    // 2. åˆå¹¶å†…éƒ¨äº¤æ˜“ä¿¡æ¯
                    internalTxList.forEach(tx => {
                        const time = parseInt(tx.timeStamp);
                        if (time < timeRange.start || time >= timeRange.end) return;
                        
                        const isUserInvolved = tx.from?.toLowerCase() === addressLower || 
                                             tx.to?.toLowerCase() === addressLower;
                        if (!isUserInvolved) return;
                        
                        if (txMap.has(tx.hash)) {
                            // åˆå¹¶åˆ°ç°æœ‰äº¤æ˜“
                            const existingTx = txMap.get(tx.hash);
                            if (!existingTx.tokens.has('BNB')) {
                                existingTx.tokens.set('BNB', { inflow: 0, outflow: 0 });
                            }
                            
                            const bnbValue = parseFloat(tx.value) / 1e18;
                            if (tx.to?.toLowerCase() === addressLower) {
                                existingTx.tokens.get('BNB').inflow += bnbValue;
                            } else if (tx.from?.toLowerCase() === addressLower) {
                                existingTx.tokens.get('BNB').outflow += bnbValue;
                            }
                        } else {
                            // åˆ›å»ºæ–°çš„å†…éƒ¨äº¤æ˜“è®°å½•
                            const bnbValue = parseFloat(tx.value) / 1e18;
                            const tokens = new Map();
                            tokens.set('BNB', {
                                inflow: tx.to?.toLowerCase() === addressLower ? bnbValue : 0,
                                outflow: tx.from?.toLowerCase() === addressLower ? bnbValue : 0
                            });
                            
                            txMap.set(tx.hash, {
                                hash: tx.hash,
                                timeStamp: tx.timeStamp,
                                from: tx.from,
                                to: tx.to,
                                value: tx.value,
                                gasPrice: '0',
                                gasUsed: '0',
                                input: '',
                                status: 'æˆåŠŸ',
                                tokens: tokens,
                                gasFee: 0,
                                txType: 'internal'
                            });
                        }
                    });
                    
                    // 3. åˆå¹¶ä»£å¸äº¤æ˜“ä¿¡æ¯
                    tokenTxList.forEach(tx => {
                        const time = parseInt(tx.timeStamp);
                        if (time < timeRange.start || time >= timeRange.end) return;
                        
                        const isUserInvolved = tx.from?.toLowerCase() === addressLower || 
                                             tx.to?.toLowerCase() === addressLower;
                        if (!isUserInvolved) return;
                        
                        const tokenSymbol = tx.tokenSymbol || 'Unknown';
                        const tokenAddress = tx.contractAddress || '';
                        const tokenValue = parseFloat(tx.value) / Math.pow(10, parseInt(tx.tokenDecimal || 18));
                        
                        console.log(`ğŸª™ å¤„ç†ä»£å¸äº¤æ˜“: ${tx.hash}, ä»£å¸: ${tokenSymbol}, é‡‘é¢: ${tokenValue}, åˆçº¦: ${tokenAddress}`);
                        
                        if (txMap.has(tx.hash)) {
                            // åˆå¹¶åˆ°ç°æœ‰äº¤æ˜“
                            const existingTx = txMap.get(tx.hash);
                            if (!existingTx.tokens.has(tokenSymbol)) {
                                existingTx.tokens.set(tokenSymbol, {
                                    inflow: 0,
                                    outflow: 0,
                                    address: tokenAddress
                                });
                            }
                            
                            if (tx.to?.toLowerCase() === addressLower) {
                                existingTx.tokens.get(tokenSymbol).inflow += tokenValue;
                                console.log(`  â¡ï¸ åˆå¹¶æµå…¥: ${tokenValue} ${tokenSymbol} åˆ°ç°æœ‰äº¤æ˜“`);
                            }
                            if (tx.from?.toLowerCase() === addressLower) {
                                existingTx.tokens.get(tokenSymbol).outflow += tokenValue;
                                console.log(`  â¬…ï¸ åˆå¹¶æµå‡º: ${tokenValue} ${tokenSymbol} åˆ°ç°æœ‰äº¤æ˜“`);
                            }
                            
                            // æ›´æ–°äº¤æ˜“ç±»å‹
                            if (existingTx.txType === 'normal') {
                                existingTx.txType = 'normal_with_token';
                            }
                        } else {
                            // åˆ›å»ºæ–°çš„ä»£å¸äº¤æ˜“è®°å½•
                            const tokens = new Map();
                            tokens.set(tokenSymbol, {
                                inflow: tx.to?.toLowerCase() === addressLower ? tokenValue : 0,
                                outflow: tx.from?.toLowerCase() === addressLower ? tokenValue : 0,
                                address: tokenAddress
                            });
                            
                            console.log(`  ğŸ†• æ–°å»ºä»£å¸äº¤æ˜“: ${tokenSymbol}, æµå…¥: ${tokens.get(tokenSymbol).inflow}, æµå‡º: ${tokens.get(tokenSymbol).outflow}`);
                            
                            txMap.set(tx.hash, {
                                hash: tx.hash,
                                timeStamp: tx.timeStamp,
                                from: tx.from,
                                to: tx.to,
                                value: '0',
                                gasPrice: '0',
                                gasUsed: '0',
                                input: tx.input || '',
                                status: 'æˆåŠŸ',
                                tokens: tokens,
                                gasFee: 0,
                                txType: 'token'
                            });
                        }
                    });
                    
                    // 4. è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åºï¼ˆé¢„å¤„ç†å®Œæˆï¼‰
                    const processedTxs = Array.from(txMap.values()).map(tx => {
                        // å°†Mapè½¬æ¢ä¸ºæ™®é€šå¯¹è±¡ä»¥ä¾¿JSONåºåˆ—åŒ–
                        const tokensObj = {};
                        tx.tokens.forEach((value, key) => {
                            tokensObj[key] = value;
                        });
                        return {
                            ...tx,
                            tokens: tokensObj
                        };
                    }).sort((a, b) => parseInt(b.timeStamp) - parseInt(a.timeStamp));
                    
                    console.log(`âš¡ å¿«é€Ÿå¤„ç†å®Œæˆ: ${processedTxs.length}æ¡åˆå¹¶äº¤æ˜“`);
                    
                    return {
                        allTransactions: processedTxs,
                        stats: {
                            total: processedTxs.length,
                            normal: processedTxs.filter(tx => tx.txType === 'normal').length,
                            internal: processedTxs.filter(tx => tx.txType === 'internal').length,
                            token: processedTxs.filter(tx => tx.txType === 'token').length
                        }
                    };
                }
                
                /**
                 * å¿«é€Ÿåˆ†æç¨³å®šå¸äº¤æ˜“æµå‘ï¼ˆUSDT + USDCï¼‰
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 * @param {Array} processedTxs - é¢„å¤„ç†çš„äº¤æ˜“æ•°æ®
                 * @returns {Object} ç¨³å®šå¸åˆ†æç»“æœ
                 */
                static async analyzeUSDTFlows(userAddress, processedTxs) {
                    const addressLower = userAddress.toLowerCase();
                    const trades = [];
                    const unknownTrades = [];
                    let totalBuy = 0, totalSell = 0, totalGasCost = 0;
                    
                    console.log(`âš¡ å¿«é€Ÿåˆ†æ ${processedTxs.length} æ¡äº¤æ˜“çš„ç¨³å®šå¸æµå‘ï¼ˆUSDT+USDCï¼‰...`);
                    
                    // ğŸš€ ç¬¬ä¸€æ­¥ï¼šæ”¶é›†éœ€è¦receiptåˆ†æçš„äº¤æ˜“
                    const needReceiptAnalysis = processedTxs.filter(tx => tx.needsReceiptAnalysis);
                    if (needReceiptAnalysis.length > 0) {
                        console.log(`ğŸ“¦ å‘ç°${needReceiptAnalysis.length}ä¸ªéœ€è¦receiptåˆ†æçš„DEXäº¤æ˜“`);
                        await this.analyzeReceiptsForUSDTFlow(needReceiptAnalysis, addressLower);
                    }
                    
                    // ğŸš€ æ‰©å±•ç¨³å®šå¸ç¬¦å·è¯†åˆ« - æ”¯æŒUSDTå’ŒUSDC
                    const stablecoinSymbols = ['USDT', 'USDC', 'BSC-USD', 'Tether USD', 'USD Coin', 'USD'];
                    
                    for (const tx of processedTxs) {
                        // ä½¿ç”¨é¢„è®¡ç®—çš„gasè´¹ç”¨ - æ— éœ€é¢å¤–APIè°ƒç”¨
                        const gasCost = tx.gasFee || 0;
                        totalGasCost += gasCost;
                        
                        console.log(`ğŸ” æ£€æŸ¥äº¤æ˜“: ${tx.hash}, ä»£å¸: ${Object.keys(tx.tokens).join(', ')}`);
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰USDTæµå‘ - æ”¯æŒå¤šç§ç¬¦å·
                        let usdtFlow = null;
                        let usdtSymbol = null;
                        let stablecoinContract = null;
                        
                        for (const symbol of stablecoinSymbols) {
                            if (tx.tokens[symbol]) {
                                usdtFlow = tx.tokens[symbol];
                                usdtSymbol = symbol;
                                stablecoinContract = tx.tokens[symbol].address || '';
                                break;
                            }
                        }
                        
                        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç¬¦å·ï¼Œå°è¯•é€šè¿‡åˆçº¦åœ°å€è¯†åˆ«ç¨³å®šå¸
                        if (!usdtFlow) {
                            for (const [symbol, data] of Object.entries(tx.tokens)) {
                                if (data.address && STABLECOIN_CONTRACTS.includes(data.address.toLowerCase())) {
                                    usdtFlow = data;
                                    usdtSymbol = symbol;
                                    stablecoinContract = data.address;
                                    
                                    // è¯†åˆ«å…·ä½“çš„ç¨³å®šå¸ç±»å‹å¹¶æ ‡å‡†åŒ–ç¬¦å·
                                    if (data.address.toLowerCase() === USDT_CONTRACT.toLowerCase()) {
                                        usdtSymbol = 'USDT';
                                        console.log(`  ğŸ¯ é€šè¿‡åˆçº¦åœ°å€è¯†åˆ«USDT: ${symbol} (${data.address})`);
                                    } else if (data.address.toLowerCase() === USDC_CONTRACT.toLowerCase()) {
                                        usdtSymbol = 'USDC';
                                        console.log(`  ğŸ¯ é€šè¿‡åˆçº¦åœ°å€è¯†åˆ«USDC: ${symbol} (${data.address})`);
                                    }
                                    break;
                                }
                            }
                        }
                        
                        if (!usdtFlow || (usdtFlow.inflow === 0 && usdtFlow.outflow === 0)) {
                            console.log(`  âŒ æ— ç¨³å®šå¸æµå‘: ${tx.hash}`);
                            // æ— ç¨³å®šå¸æµå‘ï¼Œè®°å½•ä¸ºæœªçŸ¥äº¤æ˜“
                            if (this.isRelevantTransaction(tx, addressLower)) {
                                unknownTrades.push({
                                    hash: tx.hash,
                                    timestamp: tx.timeStamp,
                                    methodId: this.getMethodId(tx.input),
                                    gasCost: gasCost,
                                    tokenAddress: this.getRelevantTokenAddress(tx),
                                    note: this.getTransactionNote(tx)
                                });
                            }
                            continue;
                        }
                        
                        console.log(`  âœ… å‘ç°ç¨³å®šå¸æµå‘ (${usdtSymbol}): æµå…¥${usdtFlow.inflow}, æµå‡º${usdtFlow.outflow}`);
                        
                        // æ£€æŸ¥æ˜¯å¦ä¸ºæ™®é€šè½¬è´¦ï¼ˆä¸è®¡å…¥ä¹°å–ç»Ÿè®¡ï¼‰
                        console.log(`ğŸ” å¼€å§‹æ£€æŸ¥æ˜¯å¦ä¸ºæ™®é€šè½¬è´¦: ${tx.hash}`);
                        
                        // ç‰¹åˆ«è°ƒè¯•é—®é¢˜äº¤æ˜“
                        if (tx.hash === '0x84d262a5be32a426a16cbeaa5463c18752d868e43184f11509f5d17e29a121cf') {
                            console.log(`ğŸš¨ğŸš¨ğŸš¨ æ­£åœ¨è°ƒè¯•é—®é¢˜transferäº¤æ˜“!`);
                            console.log(`   æ–¹æ³•ID: ${tx.input?.slice(0, 10)}`);
                            console.log(`   å®Œæ•´input: ${tx.input}`);
                            console.log(`   ç›®æ ‡åœ°å€: ${tx.to}`);
                            console.log(`   ç¨³å®šå¸åˆçº¦: ${stablecoinContract}`);
                            console.log(`   äº¤æ˜“ç±»å‹: ${tx.txType}`);
                            console.log(`   äº¤æ˜“from: ${tx.from}`);
                            console.log(`   äº¤æ˜“value: ${tx.value}`);
                            console.log(`   ä»£å¸ä¿¡æ¯: ${JSON.stringify(tx.tokens)}`);
                            console.log(`   å®Œæ•´äº¤æ˜“å¯¹è±¡:`, tx);
                        }
                        
                        const isSimpleTransfer = this.isSimpleStablecoinTransfer(tx, stablecoinContract);
                        console.log(`ğŸ” æ™®é€šè½¬è´¦æ£€æŸ¥ç»“æœ: ${isSimpleTransfer}`);
                        
                        if (isSimpleTransfer) {
                            console.log(`ğŸ“¤ è·³è¿‡æ™®é€šç¨³å®šå¸è½¬è´¦: ${tx.hash} (${usdtSymbol})`);
                            unknownTrades.push({
                                hash: tx.hash,
                                timestamp: tx.timeStamp,
                                methodId: 'simple_transfer',
                                gasCost: gasCost,
                                tokenAddress: stablecoinContract,
                                note: `æ™®é€š${usdtSymbol}è½¬è´¦ï¼ˆæœªè®¡å…¥ä¹°å–ç»Ÿè®¡ï¼‰`
                            });
                            continue;
                        }
                        
                        // åˆ†æUSDTæµå‘
                        if (usdtFlow.outflow > 0) {
                            // ç¨³å®šå¸æµå‡º = ä¹°å…¥å…¶ä»–ä»£å¸
                            trades.push({
                                hash: tx.hash,
                                usdtAmount: -usdtFlow.outflow,
                                tokenAmount: 0,
                                tokenAddress: stablecoinContract,
                                stablecoinType: usdtSymbol, // æ–°å¢å­—æ®µæ ‡è¯†ç¨³å®šå¸ç±»å‹
                                isBuy: true,
                                isSell: false,
                                timestamp: parseInt(tx.timeStamp),
                                gasCost: gasCost
                            });
                            totalBuy += usdtFlow.outflow;
                            console.log(`âœ… ${usdtSymbol}ä¹°å…¥: ${usdtFlow.outflow.toFixed(4)} ${usdtSymbol}, Gas: ${gasCost.toFixed(6)} BNB`);
                        }
                        
                        if (usdtFlow.inflow > 0) {
                            // ç¨³å®šå¸æµå…¥ = å–å‡ºå…¶ä»–ä»£å¸
                            trades.push({
                                hash: tx.hash,
                                usdtAmount: usdtFlow.inflow,
                                tokenAmount: 0,
                                tokenAddress: stablecoinContract,
                                stablecoinType: usdtSymbol, // æ–°å¢å­—æ®µæ ‡è¯†ç¨³å®šå¸ç±»å‹
                                isBuy: false,
                                isSell: true,
                                timestamp: parseInt(tx.timeStamp),
                                gasCost: gasCost
                            });
                            totalSell += usdtFlow.inflow;
                            console.log(`âœ… ${usdtSymbol}å–å‡º: ${usdtFlow.inflow.toFixed(4)} ${usdtSymbol}, Gas: ${gasCost.toFixed(6)} BNB`);
                        }
                    }
                    
                    console.log(`âš¡ å¿«é€Ÿåˆ†æå®Œæˆ: ${trades.length}ç¬”ç¨³å®šå¸äº¤æ˜“, ${unknownTrades.length}ç¬”å…¶ä»–äº¤æ˜“`);
                    
                    return {
                        trades,
                        unknownTrades,
                        totalBuyValue: totalBuy,
                        totalSellValue: totalSell,
                        totalGasCost: totalGasCost
                    };
                }
                
                // è¾…åŠ©æ–¹æ³•
                static isRelevantTransaction(tx, userAddress) {
                    return tx.from?.toLowerCase() === userAddress || tx.to?.toLowerCase() === userAddress;
                }
                
                static getMethodId(input) {
                    return input && input.length >= 10 ? input.slice(0, 10) : 'unknown';
                }
                
                static getRelevantTokenAddress(tx) {
                    // è¿”å›ç¬¬ä¸€ä¸ªéBNBä»£å¸åœ°å€
                    for (const [symbol, data] of Object.entries(tx.tokens)) {
                        if (symbol !== 'BNB' && data.address) {
                            return data.address;
                        }
                    }
                    return '';
                }
                
                static getTransactionNote(tx) {
                    if (tx.txType === 'internal') return 'å†…éƒ¨äº¤æ˜“';
                    if (tx.txType === 'token') return 'ä»£å¸äº¤æ˜“';
                    return 'æ™®é€šäº¤æ˜“';
                }
                
                static isSimpleStablecoinTransfer(tx, stablecoinContract = null) {
                    console.log(`ğŸ” æ£€æŸ¥æ˜¯å¦ä¸ºæ™®é€šç¨³å®šå¸è½¬è´¦: ${tx.hash}`);
                    console.log(`   æ–¹æ³•ID: ${tx.input?.slice(0, 10)}`);
                    console.log(`   ç›®æ ‡åœ°å€: ${tx.to}`);
                    console.log(`   ç¨³å®šå¸åˆçº¦: ${stablecoinContract}`);
                    console.log(`   äº¤æ˜“ç±»å‹: ${tx.txType}`);
                    
                    // ğŸš€ æ–°å¢ï¼šç‰¹æ®Šå¤„ç†çº¯ä»£å¸äº¤æ˜“
                    if (tx.txType === 'token') {
                        console.log(`   âœ… æ£€æµ‹åˆ°çº¯ä»£å¸äº¤æ˜“ï¼Œæ£€æŸ¥æ˜¯å¦ä¸ºç¨³å®šå¸è½¬è´¦`);
                        
                        // æ£€æŸ¥æ˜¯å¦åªæœ‰ä¸€ç§ç¨³å®šå¸æµå‘ï¼Œä¸”æ²¡æœ‰å…¶ä»–å¤æ‚ä»£å¸äº¤æ¢
                        const tokenKeys = Object.keys(tx.tokens);
                        const stablecoinKeys = tokenKeys.filter(key => 
                            STABLECOIN_CONTRACTS.includes(tx.tokens[key].address?.toLowerCase())
                        );
                        
                        console.log(`   ä»£å¸ç§ç±»: ${tokenKeys.join(', ')}`);
                        console.log(`   ç¨³å®šå¸ç§ç±»: ${stablecoinKeys.join(', ')}`);
                        
                        // å¦‚æœåªæ¶‰åŠä¸€ç§ç¨³å®šå¸ï¼Œä¸”æ²¡æœ‰å¤æ‚çš„ä»£å¸äº¤æ¢ï¼Œè®¤ä¸ºæ˜¯æ™®é€šè½¬è´¦
                        if (stablecoinKeys.length === 1 && tokenKeys.length === 1) {
                            console.log(`   âœ… çº¯ç¨³å®šå¸è½¬è´¦ï¼Œè®¤å®šä¸ºæ™®é€šè½¬è´¦`);
                            return true;
                        }
                        
                        // å¦‚æœæ¶‰åŠå¤šç§ä»£å¸æˆ–å¤æ‚äº¤æ¢ï¼Œå¯èƒ½æ˜¯äº¤æ˜“
                        if (tokenKeys.length > 1) {
                            console.log(`   âŒ æ¶‰åŠå¤šç§ä»£å¸ï¼Œå¯èƒ½æ˜¯äº¤æ˜“`);
                            return false;
                        }
                    }
                    
                    // 1. æ£€æŸ¥æ˜¯å¦æ¶‰åŠDEXè·¯ç”±
                    if (DEX_ROUTER_LIST.includes(tx.to?.toLowerCase()) || 
                        DEX_ROUTER_LIST.includes(tx.from?.toLowerCase())) {
                        console.log(`   âŒ æ¶‰åŠDEXè·¯ç”±ï¼Œä¸æ˜¯æ™®é€šè½¬è´¦`);
                        return false;
                    }
                    
                    // 2. æ£€æŸ¥æ–¹æ³•ID
                    if (tx.input && tx.input.length > 10) {
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        console.log(`   æ£€æŸ¥æ–¹æ³•ID: ${methodId}`);
                        
                        const swapMethods = [
                            '0xa03de6a9', '0x7c025200', '0x84bd6d29', '0x12aa3caf',
                            '0xe5e8894b', '0x7ff36ab5', '0x38ed1739', '0x18cbafe5'
                        ];
                        if (swapMethods.includes(methodId)) {
                            console.log(`   âŒ æ˜¯swapæ–¹æ³•ï¼Œä¸æ˜¯æ™®é€šè½¬è´¦`);
                            return false;
                        }
                        if (methodId === '0xa9059cbb') {
                            console.log(`   âœ… æ˜¯transferæ–¹æ³•ï¼Œè®¤å®šä¸ºæ™®é€šè½¬è´¦`);
                            return true; // ERC20 transferæ–¹æ³•
                        }
                    }
                    
                    // 3. æ£€æŸ¥æ˜¯å¦ç›´æ¥ä¸ç¨³å®šå¸åˆçº¦äº¤äº’
                    if (stablecoinContract && tx.to?.toLowerCase() === stablecoinContract.toLowerCase()) {
                        console.log(`   âœ… ç›´æ¥ä¸ç¨³å®šå¸åˆçº¦äº¤äº’ï¼Œè®¤å®šä¸ºæ™®é€šè½¬è´¦`);
                        return true;
                    }
                    
                    // 4. æ£€æŸ¥æ˜¯å¦ä¸ä»»ä½•ç¨³å®šå¸åˆçº¦äº¤äº’
                    if (!stablecoinContract && STABLECOIN_CONTRACTS.includes(tx.to?.toLowerCase())) {
                        console.log(`   âœ… ä¸ç¨³å®šå¸åˆçº¦äº¤äº’ï¼Œè®¤å®šä¸ºæ™®é€šè½¬è´¦`);
                        return true;
                    }
                    
                    console.log(`   âŒ ä¸ç¬¦åˆæ™®é€šè½¬è´¦æ¡ä»¶`);
                    return false;
                }
                
                /**
                 * æ£€æŸ¥æ˜¯å¦ä¸ºå¯èƒ½åŒ…å«USDTæµå‘çš„DEXäº¤æ˜“
                 * @param {Object} tx - äº¤æ˜“å¯¹è±¡
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 * @returns {boolean} æ˜¯å¦éœ€è¦è¿›ä¸€æ­¥åˆ†æ
                 */
                static isPotentialDEXTransaction(tx, userAddress) {
                    console.log(`ğŸ” æ£€æŸ¥æ˜¯å¦ä¸ºDEXäº¤æ˜“: ${tx.hash}`);
                    console.log(`   æ–¹æ³•ID: ${tx.input?.slice(0, 10)}`);
                    console.log(`   ç›®æ ‡åœ°å€: ${tx.to}`);
                    console.log(`   ç”¨æˆ·åœ°å€: ${userAddress}`);
                    console.log(`   from: ${tx.from}`);
                    
                    // ç‰¹åˆ«é’ˆå¯¹é—®é¢˜äº¤æ˜“çš„è°ƒè¯•
                    if (tx.hash === '0x65a753d80a95c83eac7b83139a88744f802dce45a3baea08e8d00587addf9a78') {
                        console.log(`ğŸ”¥ğŸ”¥ğŸ”¥ æ­£åœ¨åˆ†æé—®é¢˜äº¤æ˜“!`);
                        console.log(`   è¾“å…¥æ•°æ®: ${tx.input}`);
                        console.log(`   DEXè·¯ç”±åˆ—è¡¨é•¿åº¦: ${DEX_ROUTER_LIST.length}`);
                        console.log(`   toåœ°å€æ˜¯å¦åœ¨DEXåˆ—è¡¨ä¸­: ${DEX_ROUTER_LIST.includes(tx.to?.toLowerCase())}`);
                        if (tx.input && tx.input.length > 10) {
                            const methodId = tx.input.slice(0, 10).toLowerCase();
                            console.log(`   æå–çš„æ–¹æ³•ID: ${methodId}`);
                            console.log(`   æ˜¯å¦åŒ¹é…0xa03de6a9: ${methodId === '0xa03de6a9'}`);
                        }
                    }
                    
                    // 1. æ£€æŸ¥æ˜¯å¦æ¶‰åŠç”¨æˆ·åœ°å€
                    if (tx.from?.toLowerCase() !== userAddress && tx.to?.toLowerCase() !== userAddress) {
                        console.log(`   âŒ ä¸æ¶‰åŠç”¨æˆ·åœ°å€`);
                        return false;
                    }
                    
                    // 2. æ£€æŸ¥æ˜¯å¦æ¶‰åŠå·²çŸ¥çš„DEXè·¯ç”±
                    if (DEX_ROUTER_LIST.includes(tx.to?.toLowerCase())) {
                        console.log(`ğŸ¯ æ£€æµ‹åˆ°DEXè·¯ç”±äº¤æ˜“: ${tx.hash} -> ${tx.to}`);
                        return true;
                    }
                    
                    // 3. æ£€æŸ¥æ–¹æ³•IDæ˜¯å¦ä¸ºDEXç›¸å…³
                    if (tx.input && tx.input.length > 10) {
                        const methodId = tx.input.slice(0, 10).toLowerCase();
                        const dexMethods = [
                            '0xa03de6a9', // swapExactTokensForTokens
                            '0x7c025200', // swapExactETHForTokens  
                            '0x84bd6d29', // swapExactTokensForETH
                            '0x12aa3caf', // swapExactTokensForTokensSupportingFeeOnTransferTokens
                            '0xe5e8894b', // swapExactTokensForETHSupportingFeeOnTransferTokens
                            '0x7ff36ab5', // swapExactETHForTokensSupportingFeeOnTransferTokens
                            '0x38ed1739', // swapExactTokensForTokens
                            '0x18cbafe5', // swapExactTokensForETH
                            '0xf305d719', // addLiquidityETH
                            '0xe8e33700', // addLiquidity
                            '0x02751cec', // removeLiquidity
                            '0xaf2979eb'  // removeLiquidityETH
                        ];
                        
                        if (dexMethods.includes(methodId)) {
                            console.log(`ğŸ¯ æ£€æµ‹åˆ°DEXæ–¹æ³•: ${tx.hash} -> ${methodId}`);
                            if (methodId === '0xa03de6a9') {
                                console.log(`ğŸ”¥ ç‰¹åˆ«æ³¨æ„: è¿™æ˜¯callOneInchæ–¹æ³• ${tx.hash}`);
                            }
                            return true;
                        }
                    }
                    
                    // 4. æ£€æŸ¥Gasä½¿ç”¨é‡ï¼ˆDEXäº¤æ˜“é€šå¸¸æ¶ˆè€—æ›´å¤šGasï¼‰
                    const gasUsed = parseFloat(tx.gasUsed || '0');
                    if (gasUsed > 100000) { // è¶…è¿‡10ä¸‡Gas
                        console.log(`ğŸ¯ æ£€æµ‹åˆ°é«˜Gasäº¤æ˜“: ${tx.hash} -> ${gasUsed} gas`);
                        return true;
                    }
                    
                    return false;
                }
                
                /**
                 * åˆ†æäº¤æ˜“receiptä»¥æå–USDTæµå‘ä¿¡æ¯
                 * @param {Array} transactions - éœ€è¦åˆ†æçš„äº¤æ˜“åˆ—è¡¨
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 */
                static async analyzeReceiptsForUSDTFlow(transactions, userAddress) {
                    console.log(`ğŸ” å¼€å§‹åˆ†æ${transactions.length}ä¸ªäº¤æ˜“çš„receipt...`);
                    
                    const batchSize = 3; // æ‰¹é‡å¤„ç†é¿å…APIé™åˆ¶
                    for (let i = 0; i < transactions.length; i += batchSize) {
                        const batch = transactions.slice(i, i + batchSize);
                        console.log(`ğŸ“¦ å¤„ç†receiptæ‰¹æ¬¡: ${i+1}-${Math.min(i+batchSize, transactions.length)}/${transactions.length}`);
                        
                        // å¹¶è¡Œè·å–è¿™ä¸€æ‰¹çš„receipt
                        const receiptPromises = batch.map(async tx => {
                            try {
                                console.log(`ğŸ“¦ è·å–receipt: ${tx.hash}`);
                                await sleep(200); // 200mså»¶è¿Ÿé¿å…APIé™åˆ¶
                                const receipt = await getTxReceipt(tx.hash);
                                console.log(`âœ… è·å–receiptæˆåŠŸ: ${tx.hash}, logsæ•°é‡: ${receipt?.logs?.length || 0}`);
                                return { tx, receipt };
                            } catch (e) {
                                console.warn(`âš ï¸ è·å–receiptå¤±è´¥: ${tx.hash.slice(0, 10)}...`);
                                return { tx, receipt: null };
                            }
                        });
                        
                        const receiptResults = await Promise.all(receiptPromises);
                        
                        // åˆ†æreceiptä¸­çš„USDTæµå‘
                        for (const { tx, receipt } of receiptResults) {
                            if (receipt && receipt.logs) {
                                this.extractUSDTFlowFromReceipt(tx, receipt, userAddress);
                            }
                        }
                        
                        // æ‰¹æ¬¡é—´å»¶è¿Ÿ
                        if (i + batchSize < transactions.length) {
                            await sleep(500);
                        }
                    }
                    
                    console.log(`âœ… Receiptåˆ†æå®Œæˆ`);
                }
                
                /**
                 * ä»receiptçš„logsä¸­æå–USDTæµå‘ä¿¡æ¯
                 * @param {Object} tx - äº¤æ˜“å¯¹è±¡
                 * @param {Object} receipt - äº¤æ˜“receipt
                 * @param {string} userAddress - ç”¨æˆ·åœ°å€
                 */
                static extractUSDTFlowFromReceipt(tx, receipt, userAddress) {
                    console.log(`ğŸ” åˆ†æç¨³å®šå¸æµå‘: ${tx.hash}`);
                    console.log(`   ç”¨æˆ·åœ°å€: ${userAddress}`);
                    console.log(`   Receipt logsæ•°é‡: ${receipt?.logs?.length || 0}`);
                    
                    const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                    
                    // æŸ¥æ‰¾USDTè½¬è´¦äº‹ä»¶
                    const usdtTransfers = receipt.logs.filter(log => 
                        log.address.toLowerCase() === USDT_CONTRACT.toLowerCase() && 
                        log.topics[0] === ERC20_TRANSFER_TOPIC
                    );
                    
                    let totalInflow = 0;
                    let totalOutflow = 0;
                    
                    for (const log of usdtTransfers) {
                        try {
                            const from = '0x' + log.topics[1].slice(26).toLowerCase();
                            const to = '0x' + log.topics[2].slice(26).toLowerCase();
                            const amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                            
                            console.log(`ğŸ” USDT Transfer: ${from.slice(0, 8)}... -> ${to.slice(0, 8)}... : ${amount} USDT`);
                            
                            // æ£€æŸ¥æ˜¯å¦ä¸ç”¨æˆ·ç›¸å…³ - ç¡®ä¿ç”¨å°å†™æ¯”è¾ƒ
                            if (from === userAddress.toLowerCase()) {
                                totalOutflow += amount;
                                console.log(`  ğŸ“¤ ç”¨æˆ·USDTæµå‡º: ${amount} USDT`);
                            }
                            if (to === userAddress.toLowerCase()) {
                                totalInflow += amount;
                                console.log(`  ğŸ“¥ ç”¨æˆ·USDTæµå…¥: ${amount} USDT`);
                            }
                        } catch (e) {
                            console.warn(`âš ï¸ è§£æTransferäº‹ä»¶å¤±è´¥:`, e);
                        }
                    }
                    
                    // å°†USDTæµå‘ä¿¡æ¯æ·»åŠ åˆ°äº¤æ˜“çš„tokensä¸­
                    if (totalInflow > 0 || totalOutflow > 0) {
                        if (!tx.tokens['USDT']) {
                            tx.tokens['USDT'] = { inflow: 0, outflow: 0, address: USDT_CONTRACT };
                        }
                        tx.tokens['USDT'].inflow += totalInflow;
                        tx.tokens['USDT'].outflow += totalOutflow;
                        
                        console.log(`âœ… æå–åˆ°USDTæµå‘: ${tx.hash} -> æµå…¥${totalInflow}, æµå‡º${totalOutflow}`);
                    } else {
                        console.log(`â„¹ï¸ æœªå‘ç°USDTæµå‘: ${tx.hash}`);
                    }
                }
            }

            // è¶…å¿«åˆ†æå‡½æ•° - ä½¿ç”¨FastTransactionProcessor
            async function analyzeFast(addressInfo, transactionData, timeRange, usdtPrice, bnbPrice, usdtBalance) {
                console.log(`âš¡ ä½¿ç”¨FastTransactionProcessorè¶…å¿«åˆ†æ ${addressInfo.name}`);
                console.log(`ğŸ“Š æ•°æ®ç»Ÿè®¡:`, transactionData.stats);
                
                // ç¡®ä¿bnbPriceæ˜¯æœ‰æ•ˆçš„æ•°å­—
                if (isNaN(bnbPrice) || bnbPrice <= 0) {
                    console.warn(`æ£€æµ‹åˆ°æ— æ•ˆçš„BNBä»·æ ¼: ${bnbPrice}ï¼Œä½¿ç”¨é»˜è®¤ä»·æ ¼660`);
                    bnbPrice = 660;
                }
                
                // ä½¿ç”¨FastTransactionProcessorè¿›è¡ŒUSDTæµå‘åˆ†æ
                const result = await FastTransactionProcessor.analyzeUSDTFlows(
                    addressInfo.address, 
                    transactionData.allTransactions
                );
                
                // è®¡ç®—æœ€ç»ˆç»“æœ
                const gasCostInUSDT = result.totalGasCost * bnbPrice;
                const profitLoss = result.totalSellValue - result.totalBuyValue;
                const netProfitLoss = profitLoss - gasCostInUSDT;
                
                // è¯¦ç»†çš„åˆ†ææ‘˜è¦
                console.log(`ğŸ“‹ ${addressInfo.name} è¶…å¿«åˆ†ææ‘˜è¦:`);
                console.log(`   ğŸ“¦ æ€»äº¤æ˜“æ•°: ${transactionData.allTransactions.length}`);
                console.log(`   âœ… USDTäº¤æ˜“: ${result.trades.length}`);
                console.log(`   â“ å…¶ä»–äº¤æ˜“: ${result.unknownTrades.length}`);
                console.log(`   ğŸ’° USDTä¹°å…¥: ${result.trades.filter(t => t.isBuy).length}æ¬¡ï¼Œæ€»é¢: ${result.totalBuyValue.toFixed(2)} USDT`);
                console.log(`   ğŸ’¸ USDTå–å‡º: ${result.trades.filter(t => t.isSell).length}æ¬¡ï¼Œæ€»é¢: ${result.totalSellValue.toFixed(2)} USDT`);
                console.log(`   ğŸ“ˆ å‡€ç›ˆäº: ${profitLoss.toFixed(2)} USDT (æ‰£é™¤Gaså‰)`);
                console.log(`   ğŸ“‰ å®é™…ç›ˆäº: ${netProfitLoss.toFixed(2)} USDT (æ‰£é™¤Gaså)`);
                
                return {
                    name: addressInfo.name,
                    address: addressInfo.address,
                    trades: result.trades,
                    unknownTrades: result.unknownTrades,
                    totalBuyValue: result.totalBuyValue,
                    totalSellValue: result.totalSellValue,
                    profitLoss: profitLoss,
                    netProfitLoss: netProfitLoss,
                    totalGasCost: result.totalGasCost,
                    gasCostInUSDT: gasCostInUSDT,
                    bnbPrice: bnbPrice,
                    usdtPrice: usdtPrice,
                    usdtBalance: parseFloat(usdtBalance),
                    timeRange,
                    stats: transactionData.stats
                };
            }
        });
    </script>
</body>
</html>

