<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BSC USDT ç»Ÿè®¡åˆ†æå·¥å…·</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        .trade-card {
            transition: all 0.2s ease;
            margin-bottom: 15px;
        }
        .trade-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .buy-card {
            border-left: 4px solid #28a745;
        }
        .sell-card {
            border-left: 4px solid #dc3545;
        }
        .stats-box {
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin: 20px auto;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(#0000 10%, #3498db);
            -webkit-mask: radial-gradient(farthest-side, #0000 calc(100% - 8px), #000 0);
            mask: radial-gradient(farthest-side, #0000 calc(100% - 8px), #000 0);
            animation: spin 1s infinite linear;
        }
        .loading-text {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }
        .loading-progress {
            margin-top: 10px;
            width: 250px;
            height: 6px;
            background-color: #eee;
            border-radius: 3px;
            overflow: hidden;
        }
        .loading-progress-bar {
            height: 100%;
            background-color: #3498db;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        @keyframes spin {
            to { transform: rotate(1turn); }
        }
        .progress-info {
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 4px solid #3498db;
            padding: 10px 15px;
            margin: 10px 0;
            font-size: 14px;
            color: #333;
            border-radius: 4px;
        }
        .hidden {
            display: none;
        }
        .wallet-input {
            margin-bottom: 10px;
        }
        .wallet-input .input-group-append {
            cursor: pointer;
        }
        #addWalletBtn {
            margin-bottom: 10px;
        }
        .remove-wallet {
            cursor: pointer;
            color: #dc3545;
        }
        .wallet-addresses {
            min-height: 100px;
            font-family: monospace;
        }
        .usdt-in { color: #28a745; }
        .usdt-out { color: #dc3545; }
        .ellipsis { max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; vertical-align: bottom; }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4 text-center">BSC USDT ç»Ÿè®¡åˆ†æå·¥å…·</h1>
        
        <div class="card mb-4">
            <div class="card-body">
                <form id="analyzeForm">
                    <div class="row g-3">
                        <div class="col-md-8">
                            <label class="form-label">BSC é’±åŒ…åœ°å€ï¼ˆæ”¯æŒå¸¦åç§°ï¼Œæ¯è¡Œä¸€ä¸ªï¼‰</label>
                            <textarea class="form-control wallet-addresses" rows="5" placeholder="è¾“å…¥æ ¼å¼ï¼š
åç§° 0xå¼€å¤´çš„BSCé’±åŒ…åœ°å€
ä¾‹å¦‚ï¼š
å¿µå®‰1 0xXX
å¿µå®‰2 0xXX" required></textarea>
                            <small class="text-muted">æ¯è¡Œä¸€ä¸ªåœ°å€ï¼Œå¯ä»¥åœ¨åœ°å€å‰åŠ åç§°ï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼‰</small>
                        </div>
                        <div class="col-md-4">
                            <label for="date" class="form-label">ç»Ÿè®¡æ—¥æœŸ</label>
                            <input type="date" class="form-control" id="date">
                            <small class="text-muted">ä¸å¡«é»˜è®¤ç»Ÿè®¡ä»Šå¤©8:00åˆ°æ˜å¤©8:00çš„æ•°æ®</small>
                        </div>
                        <div class="col-md-4">
                            <label for="txLimit" class="form-label">äº¤æ˜“å¤„ç†é™åˆ¶</label>
                            <select class="form-control" id="txLimit">
                                <option value="50">ä»…å¤„ç†æœ€è¿‘50ç¬”äº¤æ˜“</option>
                                <option value="100">ä»…å¤„ç†æœ€è¿‘100ç¬”äº¤æ˜“</option>
                                <option value="200">ä»…å¤„ç†æœ€è¿‘200ç¬”äº¤æ˜“</option>
                                <option value="all" selected>å¤„ç†æ‰€æœ‰äº¤æ˜“</option>
                            </select>
                            <small class="text-muted">é™åˆ¶å¤„ç†çš„äº¤æ˜“æ•°é‡å¯ä»¥æé«˜æ€§èƒ½</small>
                        </div>
                    </div>
                    <div class="row mt-3">
                        <div class="col-12">
                            <button type="submit" class="btn btn-primary">
                                <span class="normal-text">åˆ†æ</span>
                                <span class="spinner-border spinner-border-sm hidden" id="submitSpinner" role="status"></span>
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <div id="errorMessage" class="alert alert-danger hidden" role="alert"></div>
        <div id="loader" class="loader hidden">
            <div class="loading-spinner"></div>
            <div class="loading-text">æ­£åœ¨åˆ†æäº¤æ˜“æ•°æ®...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" style="width: 0%"></div>
            </div>
            <div id="loading-detail" class="loading-text"></div>
        </div>

        <div id="resultContainer" class="hidden">
            <div class="card mb-4">
                <div class="card-header">
                    <h4>åˆ†æç»“æœ</h4>
                    <p class="text-muted mb-0" id="timeRangeInfo"></p>
                </div>
            </div>

            <!-- è´¦æˆ·åˆ†æç»“æœå®¹å™¨ -->
            <div id="accountsContainer"></div>

            <div id="noTradesMessage" class="alert alert-info hidden">åœ¨æŒ‡å®šæ—¶é—´èŒƒå›´å†…æ²¡æœ‰æ‰¾åˆ°USDTä¹°å–</div>
        </div>
        
        <div class="mt-4 text-center">
            <p class="text-muted mb-2">
                ä½œè€…: ä¸œä¸œ 
                <a href="https://x.com/lumaodaren" target="_blank" class="text-decoration-none">
                    <i class="bi bi-twitter-x"></i> @lumaodaren
                </a>
            </p>
            <p class="text-muted">
                <a href="https://github.com/sincitysh/bscalpha" target="_blank" class="text-decoration-none">
                    <i class="bi bi-github"></i> æŸ¥çœ‹æºç 
                </a>
                |
                æœ¬å·¥å…·åœ¨GitHub Pagesä¸Šè¿è¡Œï¼Œæ— éœ€æœåŠ¡å™¨
            </p>
        </div>
    </div>

    <!-- æ·»åŠ Web3.jsåº“ -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    
    <!-- æ·»åŠ Bootstrapçš„JavaScriptä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        function getTimeRange(dateStr) {
            const now = new Date();
            // å…ˆè½¬ä¸ºåŒ—äº¬æ—¶é—´
            const beijingOffset = 8 * 60; // ä¸œå…«åŒº
            const localOffset = now.getTimezoneOffset();
            const diff = beijingOffset + localOffset;
            const beijingNow = new Date(now.getTime() + diff * 60 * 1000);

            let startDate, endDate;
            if (dateStr) {
                startDate = new Date(dateStr);
                startDate.setHours(8, 0, 0, 0);
            } else {
                startDate = new Date(beijingNow);
                startDate.setHours(8, 0, 0, 0);
                if (beijingNow.getHours() < 8) startDate.setDate(startDate.getDate() - 1);
            }
            endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 1);
            return {
                start: Math.floor(startDate.getTime() / 1000),
                end: Math.floor(endDate.getTime() / 1000),
                startDate, endDate
            };
        }

        const USDT_CONTRACT = '0x55d398326f99059fF775485246999027B3197955';

        const BSCSCAN_API_KEYS = [
            'GFCARE1KCXRXZUTWYCRV9K65Q1V8BXZU3K',
            'AMQYJJTKB7H8GGSDY3K42G989M6S7INCFG',
            'R613WACX85IZPMASA6K8EAXTT85JQQG6J8',
            'W8U2D8MVYQCVN2TR1FU5IJB186436997CF',
            'T8RZ9IAIMPPDE665TSIP14Y3RYAWK23W3I'
        ];

        function getRandomApiKey() {
            const randomIndex = Math.floor(Math.random() * BSCSCAN_API_KEYS.length);
            return BSCSCAN_API_KEYS[randomIndex];
        }

        const DEX_ROUTER_LIST = [
            '0x10ed43c718714eb63d5aa57b78b54704e256024e', // PancakeSwap v2
            '0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F', // PancakeSwap v1
            '0x3a6d8ca21d1cf76f653a67577fa0d27453350dd8', // BiSwap
            '0xcDe540d7eAFE93aC5fE6233Bee57E1270D3E330F', // BakerySwap
            '0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607', // ApeSwap
            '0x7a6e4e3cc2ac9924605dc68f5d95e75e5f629b31', // Mdex Router
            '0x1b96b92314c44b159149f7e0303511fb2fc4774f', // PancakeSwap v2 (è€è·¯ç”±)
            '0x1111111254eeb25477b68fb85ed929f73a960582', // 1inch v4 Router
            '0x11111112542d85b3ef69ae05771c2dccff4faa26', // 1inch v3 Router
            '0x111111125434b319222cdbf8c261674adb56f3ae', // 1inch v2 Router
        ];

        // å®šä¹‰è·¯ç”±åœ°å€
        const routerAddresses = {
            'PancakeSwap': '0x10ED43C718714eb63d5aA57B78B54704E256024E'.toLowerCase(),
            'BiSwap': '0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8'.toLowerCase(),
            'BaseSwap': '0x13f4EA83D0bd40E75C8222255bc855a974568Dd4'.toLowerCase(),
            'BaseSwapRouter': '0xb300000b72deaeb607a12d5f54773d1c19c7028d'.toLowerCase(), // ç¡®ä¿è¿™ä¸ªåœ°å€æ­£ç¡®æ·»åŠ 
            // ... å…¶ä»–åœ°å€ ...
        };

        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('analyzeForm');
            const loader = document.getElementById('loader');
            const errorMessage = document.getElementById('errorMessage');
            const resultContainer = document.getElementById('resultContainer');
            const submitSpinner = document.getElementById('submitSpinner');
            const noTradesMessage = document.getElementById('noTradesMessage');
            
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // è·å–å¹¶å¤„ç†é’±åŒ…åœ°å€
                const addressesText = form.querySelector('.wallet-addresses').value;
                const addressEntries = addressesText.split('\n')
                    .map(line => {
                        const parts = line.trim().split(/[\s\t]+/);
                        if (parts.length >= 2) {
                            return {
                                name: parts[0],
                                address: parts[parts.length - 1].trim()
                            };
                        } else if (parts.length === 1 && parts[0]) {
                            return {
                                name: 'æœªå‘½å',
                                address: parts[0].trim()
                            };
                        }
                        return null;
                    })
                    .filter(Boolean);
                
                // éªŒè¯åœ°å€
                for (const entry of addressEntries) {
                    if (!isValidAddress(entry.address)) {
                        errorMessage.textContent = `æ— æ•ˆçš„é’±åŒ…åœ°å€æ ¼å¼: ${entry.address}`;
                        errorMessage.classList.remove('hidden');
                        return;
                    }
                }

                if (addressEntries.length === 0) {
                    errorMessage.textContent = 'è¯·è‡³å°‘è¾“å…¥ä¸€ä¸ªé’±åŒ…åœ°å€';
                    errorMessage.classList.remove('hidden');
                    return;
                }
                
                const date = document.getElementById('date').value;
                
                console.log('å¼€å§‹åˆ†æï¼Œè¾“å…¥çš„é’±åŒ…åœ°å€ï¼š', addressesText);
                console.log('è§£æåçš„åœ°å€å¯¹è±¡ï¼š', addressEntries);
                console.log('é€‰æ‹©çš„æ—¥æœŸï¼š', date);
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                toggleLoading(true);
                errorMessage.classList.add('hidden');
                errorMessage.textContent = '';
                resultContainer.classList.add('hidden');
                
                try {
                    // è·å–æ—¶é—´èŒƒå›´
                    const timeRange = getTimeRange(date);
                    console.log('ç»Ÿè®¡æ—¶é—´èŒƒå›´:', timeRange);
                    
                    // è·å–æ‰€æœ‰åœ°å€çš„äº¤æ˜“
                    let allTransactions = [];
                    const errors = [];
                    
                    // ä¸²è¡Œå¤„ç†æ¯ä¸ªåœ°å€ï¼Œé¿å…å¹¶å‘è¯·æ±‚
                    for (const entry of addressEntries) {
                        try {
                            console.log(`å¼€å§‹è·å–åœ°å€ ${entry.name} (${entry.address}) çš„USDTè½¬è´¦...`);
                            const txLimit = document.getElementById('txLimit').value;
                            const transfers = await getUSDTTransfers(entry.address, timeRange, txLimit);
                            console.log(`åœ°å€ ${entry.name} è·å–åˆ° ${transfers.length} æ¡USDTè½¬è´¦`);
                            console.log(`ã€${entry.name}ã€‘USDTè½¬è´¦åŸå§‹æ•°æ®:`, transfers);
                            allTransactions = allTransactions.concat(transfers.map(tx => ({...tx, accountName: entry.name})));
                        } catch (error) {
                            errors.push(`${entry.name}: ${error.message}`);
                            console.error(`å¤„ç†åœ°å€ ${entry.name} æ—¶å‡ºé”™:`, error);
                        }
                    }
                    
                    // å¦‚æœæœ‰é”™è¯¯ä½†ä»æœ‰ä¸€äº›æˆåŠŸçš„ç»“æœï¼Œæ˜¾ç¤ºè­¦å‘Š
                    if (errors.length > 0) {
                        const warningDiv = document.createElement('div');
                        warningDiv.className = 'alert alert-warning';
                        warningDiv.innerHTML = `
                            <h5>éƒ¨åˆ†æ•°æ®è·å–å¤±è´¥</h5>
                            <ul class="mb-0">
                                ${errors.map(err => `<li>${err}</li>`).join('')}
                            </ul>
                        `;
                        resultContainer.insertBefore(warningDiv, resultContainer.firstChild);
                    }
                    
                    // å¦‚æœå®Œå…¨æ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºé”™è¯¯
                    if (allTransactions.length === 0 && errors.length > 0) {
                        throw new Error('æ‰€æœ‰åœ°å€çš„æ•°æ®è·å–å‡å¤±è´¥');
                    }
                    
                    if (allTransactions.length === 0) {
                        resultContainer.classList.remove('hidden');
                        noTradesMessage.classList.remove('hidden');
                        document.getElementById('timeRangeInfo').textContent = `ç»Ÿè®¡æ—¶é—´: ${formatTime(timeRange.start)} è‡³ ${formatTime(timeRange.end)}`;
                        return;
                    }
                    
                    // è·å–å½“å‰USDTä»·æ ¼
                    const usdtPrice = await getUSDTPrice();
                    
                    // è·å–æ‰€æœ‰åœ°å€çš„USDTä½™é¢æ€»å’Œ
                    let totalBalance = 0;
                    for (const entry of addressEntries) {
                        const balance = await getUSDTBalance(entry.address);
                        totalBalance += parseFloat(balance);
                    }
                    
                    // åˆ†æäº¤æ˜“
                    const allAnalysis = [];
                    for (const entry of addressEntries) {
                        const txs = allTransactions.filter(tx => tx.accountName === entry.name);
                        const bnbPrice = await getBNBPrice();
                        const analysis = await analyzeTransactions(entry, txs, timeRange, usdtPrice, bnbPrice, await getUSDTBalance(entry.address));
                        allAnalysis.push(analysis);
                    }
                    
                    // æ¸²æŸ“ç»“æœ
                    await renderResults({
                        success: true,
                        addressEntries,
                        allAnalysis
                    });
                    
                    resultContainer.classList.remove('hidden');
                } catch (error) {
                    console.error('åˆ†æå¤±è´¥:', error);
                    errorMessage.textContent = error.message || 'å¤„ç†è¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯';
                    errorMessage.classList.remove('hidden');
                } finally {
                    toggleLoading(false);
                }
            });
            
            function toggleLoading(isLoading) {
                if (isLoading) {
                    loader.classList.remove('hidden');
                    submitSpinner.classList.remove('hidden');
                    document.querySelector('.normal-text').classList.add('hidden');
                    document.querySelector('.loading-progress-bar').style.width = '0%';
                    document.getElementById('loading-detail').textContent = 'å‡†å¤‡åˆ†æ...';
                } else {
                    loader.classList.add('hidden');
                    submitSpinner.classList.add('hidden');
                    document.querySelector('.normal-text').classList.remove('hidden');
                }
            }
            
            function isValidAddress(address) {
                return /^0x[a-fA-F0-9]{40}$/.test(address);
            }
            
            // è·å–USDTä»·æ ¼ï¼ˆUSDTå¯¹USDTæ°¸è¿œæ˜¯1ï¼‰
            async function getUSDTPrice() {
                return 1;
            }
            
            // è·å–USDTä½™é¢
            async function getUSDTBalance(address) {
                const url = `https://api.bscscan.com/api?module=account&action=tokenbalance&contractaddress=${USDT_CONTRACT}&address=${address}&tag=latest&apikey=${getRandomApiKey()}`;
                const res = await fetch(url);
                const data = await res.json();
                return parseFloat(data.result) / 1e18;
            }
            
            // è·å–åœ°å€äº¤æ˜“
            async function getTxList(address, timeRange) {
                const url = `https://api.bscscan.com/api?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&starttime=${timeRange.start}&endtime=${timeRange.end}&sort=asc&apikey=${getRandomApiKey()}`;
                const res = await fetch(url);
                const data = await res.json();
                if (!Array.isArray(data.result)) {
                    console.error('BscScanè¿”å›å¼‚å¸¸:', data);
                    return [];
                }
                return data.result;
            }
            
            // ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è¯·æ±‚
            const receiptCache = {};
            const txDetailCache = {};
            
            async function getTxReceipt(txHash) {
                if (receiptCache[txHash]) return receiptCache[txHash];
                
                const url = `https://api.bscscan.com/api?module=proxy&action=eth_getTransactionReceipt&txhash=${txHash}&apikey=${getRandomApiKey()}`;
                try {
                    const res = await fetch(url);
                    const data = await res.json();
                    receiptCache[txHash] = data.result;
                    return data.result;
                } catch (e) {
                    console.error(`è·å–äº¤æ˜“æ”¶æ®å¤±è´¥: ${txHash}`, e);
                    return null;
                }
            }
            
            async function getTxDetail(txHash) {
                if (txDetailCache[txHash]) return txDetailCache[txHash];
                
                const url = `https://api.bscscan.com/api?module=proxy&action=eth_getTransactionByHash&txhash=${txHash}&apikey=${getRandomApiKey()}`;
                try {
                    const res = await fetch(url);
                    const data = await res.json();
                    txDetailCache[txHash] = data.result;
                    return data.result;
                } catch (e) {
                    console.error(`è·å–äº¤æ˜“è¯¦æƒ…å¤±è´¥: ${txHash}`, e);
                    return null;
                }
            }
            
            // è·å–åœ°å€USDTç›¸å…³çš„æ‰€æœ‰è½¬è´¦ï¼ˆåŒ…æ‹¬åˆçº¦å†…éƒ¨swapï¼‰
            async function getUSDTTransfers(address, timeRange, txLimit) {
                // åŒæ—¶è·å–ä»£å¸è½¬è´¦å’Œæ™®é€šäº¤æ˜“ï¼Œç¡®ä¿æ•è·æ‰€æœ‰å¯èƒ½çš„USDTäº¤æ˜“
                const [tokenTxs, normalTxs] = await Promise.all([
                    // è·å–USDTä»£å¸è½¬è´¦
                    (async () => {
                        const url = `https://api.bscscan.com/api?module=account&action=tokentx&contractaddress=${USDT_CONTRACT}&address=${address}&startblock=0&endblock=99999999&starttime=${timeRange.start}&endtime=${timeRange.end}&sort=asc&apikey=${getRandomApiKey()}`;
                        const res = await fetch(url);
                        const data = await res.json();
                        return Array.isArray(data.result) ? data.result : [];
                    })(),
                    // è·å–æ‰€æœ‰æ™®é€šäº¤æ˜“ï¼Œä½†é™åˆ¶å¤„ç†æ•°é‡
                    (async () => {
                        const url = `https://api.bscscan.com/api?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&starttime=${timeRange.start}&endtime=${timeRange.end}&sort=asc&apikey=${getRandomApiKey()}`;
                        const res = await fetch(url);
                        const data = await res.json();
                        let allTxs = Array.isArray(data.result) ? data.result : [];
                        
                        // é¦–å…ˆç­›é€‰æ—¶é—´èŒƒå›´
                        allTxs = allTxs.filter(tx => {
                            const txTime = parseInt(tx.timeStamp);
                            return txTime >= timeRange.start && txTime <= timeRange.end;
                        });
                        
                        console.log(`è·å–åˆ° ${allTxs.length} æ¡ç¬¦åˆæ—¶é—´èŒƒå›´çš„æ™®é€šäº¤æ˜“`);
                        
                        // å†åº”ç”¨äº¤æ˜“é™åˆ¶
                        if (txLimit !== 'all') {
                            const limitNum = parseInt(txLimit);
                            allTxs = allTxs.slice(-limitNum);
                            console.log(`åº”ç”¨äº¤æ˜“é™åˆ¶ï¼Œä»…å¤„ç†æœ€è¿‘ ${txLimit} ç¬”äº¤æ˜“`);
                        }
                        
                        return allTxs;
                    })()
                ]);
                
                console.log(`åœ°å€ ${address} USDTä»£å¸è½¬è´¦: ${tokenTxs.length}æ¡`);
                console.log(`åœ°å€ ${address} æ™®é€šäº¤æ˜“: ${normalTxs.length}æ¡`);
                
                // åˆå¹¶äº¤æ˜“æ•°æ®ï¼Œç¡®ä¿ä¸é‡å¤
                const hashSet = new Set();
                const mergedTxs = [];
                
                // æ·»åŠ USDTä»£å¸è½¬è´¦
                for (const tx of tokenTxs) {
                    hashSet.add(tx.hash);
                    mergedTxs.push(tx);
                }
                
                // åˆ†æ‰¹å¤„ç†æ™®é€šäº¤æ˜“ï¼Œæ¯æ‰¹å¤„ç†50ä¸ª
                const batchSize = 50;
                const totalTxs = normalTxs.length;
                for (let i = 0; i < normalTxs.length; i += batchSize) {
                    const batch = normalTxs.slice(i, i + batchSize);
                    const progress = Math.min(100, Math.round((i / totalTxs) * 100));
                    console.log(`å¤„ç†ç¬¬ ${i/batchSize + 1} æ‰¹äº¤æ˜“ (${i}-${i+batch.length})`);
                    
                    // æ›´æ–°UIä»¥æ˜¾ç¤ºè¿›åº¦
                    document.getElementById('loading-detail').textContent = `å¤„ç†ä¸­: ${i}/${totalTxs} æ¡äº¤æ˜“`;
                    document.querySelector('.loading-progress-bar').style.width = `${progress}%`;
                    
                    // ç»™UIæ—¶é—´æ›´æ–°
                    await new Promise(resolve => setTimeout(resolve, 0));
                    
                    for (const tx of batch) {
                        // å¦‚æœå·²ç»æœ‰è¿™ä¸ªhashäº†ï¼Œè·³è¿‡
                        if (hashSet.has(tx.hash)) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯swapäº¤æ˜“
                        if (tx.input && tx.input.length >= 10) {
                            const methodId = tx.input.slice(0, 10).toLowerCase();
                            const swapMethods = [
                                '0xa03de6a9', // 1inch callOneInch
                                '0x7c025200', // 1inch swap
                                '0x84bd6d29', // 1inch clipperSwap
                                '0x12aa3caf', // 1inch swap variant
                                '0xe449022e', // 1inch uniswapV3Swap
                                '0x90411a32', // 1inch swap variant
                                '0xdad12b6c', // 1inch proxySwap
                                '0xe5e8894b', // 1inch proxySwapV2
                                '0x7ff36ab5', // PancakeSwap swapExactETHForTokens
                                '0x38ed1739', // PancakeSwap swapExactTokensForTokens
                                '0x18cbafe5', // PancakeSwap swapExactTokensForETH
                                '0x8803dbee', // PancakeSwap swapTokensForExactTokens
                            ];
                            
                            const isDexRouter = DEX_ROUTER_LIST.includes(tx.to.toLowerCase());
                            
                            if (swapMethods.includes(methodId) || isDexRouter) {
                                // è¿™å¯èƒ½æ˜¯ä¸€ä¸ªswapäº¤æ˜“ï¼Œè·å–äº¤æ˜“æ”¶æ®æ£€æŸ¥æ˜¯å¦æ¶‰åŠUSDT
                                const receipt = await getTxReceipt(tx.hash);
                                if (receipt && receipt.logs) {
                                    const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                                    const hasUsdtTransfer = receipt.logs.some(log => 
                                        log.address.toLowerCase() === USDT_CONTRACT.toLowerCase() && 
                                        log.topics[0] === ERC20_TRANSFER_TOPIC
                                    );
                                    
                                    if (hasUsdtTransfer) {
                                        console.log(`å‘ç°swapäº¤æ˜“æ¶‰åŠUSDT: ${tx.hash} (æ–¹æ³•ID: ${methodId})`);
                                        // ä¸ºäº†ä¿æŒæ ¼å¼ä¸€è‡´ï¼Œæ·»åŠ contractAddresså­—æ®µ
                                        tx.contractAddress = USDT_CONTRACT;
                                        mergedTxs.push(tx);
                                        hashSet.add(tx.hash);
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log(`åˆå¹¶åæ€»å…±: ${mergedTxs.length}æ¡äº¤æ˜“`);
                return mergedTxs;
            }
            
            // è§£æäº¤æ˜“æ•°æ®
            async function analyzeTransactions(addressInfo, transfers, timeRange, usdtPrice, bnbPrice, usdtBalance) {
                const grouped = groupByHash(transfers);
                console.log(`ã€${addressInfo.name}ã€‘USDTè½¬è´¦åˆ†ç»„ï¼ˆæŒ‰hashï¼‰:`, grouped.map(g => g[0].hash));
                const trades = [];
                let totalBuy = 0, totalSell = 0, totalGasCost = 0;
                
                const totalTxs = grouped.length;
                document.getElementById('loading-detail').textContent = `åˆ†æ ${addressInfo.name} çš„äº¤æ˜“: 0/${totalTxs}`;
                document.querySelector('.loading-progress-bar').style.width = '0%';
                
                for (let i = 0; i < grouped.length; i++) {
                    const progress = Math.min(100, Math.round((i / totalTxs) * 100));
                    document.getElementById('loading-detail').textContent = `åˆ†æ ${addressInfo.name} çš„äº¤æ˜“: ${i+1}/${totalTxs}`;
                    document.querySelector('.loading-progress-bar').style.width = `${progress}%`;
                    
                    const txGroup = grouped[i];
                    const tx = txGroup[0];
                    const time = parseInt(tx.timeStamp);
                    
                    if (time < timeRange.start || time >= timeRange.end) continue;
                    
                    // æ·»åŠ è¶…æ—¶å¤„ç†
                    const tradePromise = analyzeTxGroup(txGroup, addressInfo.address);
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('åˆ†æè¶…æ—¶')), 10000)
                    );
                    
                    try {
                        const trade = await Promise.race([tradePromise, timeoutPromise]);
                        if (trade) {
                            trades.push(trade);
                            if (trade.isBuy) totalBuy += Math.abs(trade.usdtAmount);
                            if (trade.isSell) totalSell += Math.abs(trade.usdtAmount);
                            totalGasCost += trade.gasCost || 0;
                        }
                    } catch (e) {
                        console.error(`åˆ†æäº¤æ˜“ ${tx.hash} å¤±è´¥:`, e);
                        // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªäº¤æ˜“
                    }
                }
                
                // ä¸éœ€è¦ç§»é™¤progressDivï¼Œè€Œæ˜¯æ¸…ç©ºåŠ è½½è¯¦æƒ…
                document.getElementById('loading-detail').textContent = 'åˆ†æå®Œæˆ';
                
                const gasCostInUSDT = totalGasCost * bnbPrice;
                const netProfitLoss = totalSell - totalBuy - gasCostInUSDT;
                
                const analysis = {
                    name: addressInfo.name,
                    address: addressInfo.address,
                    trades,
                    totalBuyValue: totalBuy,
                    totalSellValue: totalSell,
                    profitLoss: totalSell - totalBuy,
                    netProfitLoss: netProfitLoss,
                    totalGasCost: totalGasCost,
                    gasCostInUSDT: gasCostInUSDT,
                    bnbPrice: bnbPrice,
                    usdtPrice: usdtPrice,
                    usdtBalance: parseFloat(usdtBalance),
                    timeRange
                };
                return analysis;
            }
            
            async function renderResults(data) {
                const { addressEntries, allAnalysis } = data;
                const accountsContainer = document.getElementById('accountsContainer');
                accountsContainer.innerHTML = '';

                // è®¡ç®—æ€»äºæŸå’Œæ˜¯å¦æœ‰äº¤æ˜“
                let totalLoss = 0;
                let totalTrades = 0;
                allAnalysis.forEach(analysis => {
                    totalLoss += analysis.netProfitLoss < 0 ? Math.abs(analysis.netProfitLoss) : 0;
                    totalTrades += analysis.trades.length;
                });

                // åˆ›å»ºæ€»ç»“å¡ç‰‡
                const summaryCard = document.createElement('div');
                summaryCard.className = 'card mb-4';
                
                if (totalTrades === 0) {
                    summaryCard.innerHTML = `
                        <div class="card-body bg-info text-white">
                            <h5 class="card-title">âš ï¸ æœªæ£€æµ‹åˆ°äº¤æ˜“è®°å½•</h5>
                            <p class="mb-0">å¯èƒ½åŸå› ï¼š</p>
                            <ul class="mb-0">
                                <li>ä»Šæ—¥æœªè¿›è¡Œäº¤æ˜“</li>
                                <li>API è®¿é—®å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•</li>
                                <li>é€‰æ‹©çš„æ—¶é—´èŒƒå›´å†…æ— äº¤æ˜“</li>
                            </ul>
                        </div>
                    `;
                } else if (totalLoss < 5) {
                    const pigFeetMeals = Math.ceil(totalLoss / 2);
                    summaryCard.innerHTML = `
                        <div class="card-body bg-warning">
                            <h5 class="card-title">ğŸ˜… ä»Šæ—¥å°äº ${totalLoss.toFixed(2)} USDT</h5>
                            <p class="mb-0">ç›¸å½“äºä¸¢å¤±äº† ${pigFeetMeals} é¡¿çŒªè„šé¥­ (æŒ‰2U/é¡¿è®¡ç®—)</p>
                            <small class="text-muted">åˆ«ç°å¿ƒï¼Œæ˜å¤©ä¼šæ›´å¥½ï¼</small>
                        </div>
                    `;
                } else if (totalLoss >= 50) {
                    const hotPotMeals = Math.ceil(totalLoss / 50);
                    summaryCard.innerHTML = `
                        <div class="card-body bg-danger text-white">
                            <h5 class="card-title">ğŸ˜± ä»Šæ—¥å¤§äº ${totalLoss.toFixed(2)} USDT</h5>
                            <p class="mb-0">ç›¸å½“äºé”™è¿‡äº† ${hotPotMeals} é¡¿æµ·åº•æ (æŒ‰50U/é¡¿è®¡ç®—)</p>
                            <small>å»ºè®®ä¼‘æ¯ä¸€ä¸‹ï¼Œè°ƒæ•´å¿ƒæ€ï¼</small>
                        </div>
                    `;
                } else {
                    const pigFeetMeals = Math.ceil(totalLoss / 2);
                    summaryCard.innerHTML = `
                        <div class="card-body bg-warning">
                            <h5 class="card-title">ğŸ˜“ ä»Šæ—¥äºæŸ ${totalLoss.toFixed(2)} USDT</h5>
                            <p class="mb-0">ç›¸å½“äºä¸¢å¤±äº† ${pigFeetMeals} é¡¿çŒªè„šé¥­ (æŒ‰2U/é¡¿è®¡ç®—)</p>
                            <small class="text-muted">è°ƒæ•´ç­–ç•¥ï¼Œæ˜å¤©ç»§ç»­ï¼</small>
                        </div>
                    `;
                }

                // å°†æ€»ç»“å¡ç‰‡æ’å…¥åˆ°ç»“æœå®¹å™¨çš„å¼€å¤´
                accountsContainer.insertBefore(summaryCard, accountsContainer.firstChild);

                // ç»§ç»­æ¸²æŸ“åŸæœ‰çš„è´¦æˆ·åˆ†æç»“æœ
                for (let i = 0; i < addressEntries.length; i++) {
                    const entry = addressEntries[i];
                    const analysis = allAnalysis[i];
                    // è·å–å½“å‰USDTä½™é¢
                    const balance = await getUSDTBalance(entry.address);
                    
                    const accountCard = document.createElement('div');
                    accountCard.className = 'card mb-4';
                    accountCard.innerHTML = `
                        <div class="card-header bg-light">
                            <h5 class="mb-0">
                                <i class="bi bi-person-circle"></i> 
                                ${entry.name}
                                <small class="text-muted">${entry.address}</small>
                            </h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="stats-box bg-light">
                                        <h6 class="border-bottom pb-2">USDTä¹°å–ç»Ÿè®¡</h6>
                                        <div class="d-flex justify-content-between">
                                            <span>ä¹°å…¥æ€»é¢:</span>
                                            <span class="fw-bold usdt-out">${analysis.totalBuyValue.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>å–å‡ºæ€»é¢:</span>
                                            <span class="fw-bold usdt-in">${analysis.totalSellValue.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>å‡€ç›ˆäº:</span>
                                            <span class="fw-bold">${analysis.netProfitLoss.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>å½“å‰USDTä½™é¢:</span>
                                            <span class="fw-bold">${balance.toFixed(6)} USDT</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>æ€»Gasæ¶ˆè€—:</span>
                                            <span class="fw-bold">${analysis.totalGasCost.toFixed(6)} BNB â‰ˆ ${analysis.gasCostInUSDT.toFixed(2)} USDT</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-8">
                                    <div class="stats-box bg-light">
                                        <h6 class="border-bottom pb-2">USDTä¹°å–æ˜ç»†</h6>
                                        <div class="table-responsive">
                                            <table class="table table-sm table-bordered">
                                                <thead>
                                                    <tr>
                                                        <th>æ—¶é—´</th>
                                                        <th>ç±»å‹</th>
                                                        <th>USDTé‡‘é¢</th>
                                                        <th>ä»£å¸é‡‘é¢</th>
                                                        <th>ä»£å¸åˆçº¦</th>
                                                        <th>äº¤æ˜“</th>
                                                        <th>Gasè´¹ç”¨ï¼ˆBNBï¼‰</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    ${
                                                        analysis.trades.length === 0
                                                        ? '<tr><td colspan="6">æ— USDTä¹°å–è®°å½•</td></tr>'
                                                        : analysis.trades.map(d => `
                                                            <tr>
                                                                <td>${formatTime(d.timestamp)}</td>
                                                                <td class="${d.usdtAmount < 0 ? 'usdt-out' : 'usdt-in'}">
                                                                    ${d.usdtAmount < 0 ? 'ç”¨USDTä¹°å…¥' : 'ç”¨å…¶ä»–å¸æ¢USDT'}
                                                                </td>
                                                                <td>${Math.abs(d.usdtAmount).toFixed(6)}</td>
                                                                <td>${d.tokenAmount.toFixed(6)}</td>
                                                                <td class="ellipsis" title="${d.tokenAddress}">${d.tokenAddress}</td>
                                                                <td><a href="https://bscscan.com/tx/${d.hash}" target="_blank">æŸ¥çœ‹</a></td>
                                                                <td>${d.gasCost ? d.gasCost.toFixed(6) : '-'}</td>
                                                            </tr>
                                                        `).join('')
                                                    }
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    accountsContainer.appendChild(accountCard);
                }
                console.log('æ¸²æŸ“åˆ†æç»“æœï¼š', allAnalysis);
            }

            function formatTime(ts) {
                return new Date(ts * 1000).toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', hour12: false });
            }

            // è§£æä¸€ç¬”äº¤æ˜“ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºUSDTä¹°å…¥/å–å‡º
            async function analyzeTx(tx, address) {
                const receipt = await getTxReceipt(tx.hash);
                if (!receipt || !receipt.logs) return null;
                const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                let usdtIn = 0, usdtOut = 0, tokenIn = 0, tokenOut = 0, tokenAddress = '';
                for (const log of receipt.logs) {
                    if (log.topics[0] === ERC20_TRANSFER_TOPIC) {
                        const contract = log.address.toLowerCase();
                        const from = '0x' + log.topics[1].slice(26).toLowerCase();
                        const to = '0x' + log.topics[2].slice(26).toLowerCase();
                        let amount = 0;
                        try {
                            if (log.data && log.data !== "0x") {
                                amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                            }
                        } catch (e) {
                            amount = 0;
                        }
                        if (contract === USDT_CONTRACT.toLowerCase()) {
                            if (from === address.toLowerCase()) usdtOut += amount;
                            if (to === address.toLowerCase()) usdtIn += amount;
                        } else if (from === address.toLowerCase() || to === address.toLowerCase()) {
                            if (!tokenAddress) tokenAddress = contract;
                            if (from === address.toLowerCase()) tokenOut += amount;
                            if (to === address.toLowerCase()) tokenIn += amount;
                        }
                    }
                }
                if (usdtOut > 0 && tokenIn > 0) {
                    return {
                        hash: tx.hash,
                        usdtAmount: -usdtOut,
                        tokenAmount: tokenIn,
                        tokenAddress,
                        isBuy: true,
                        isSell: false,
                        timestamp: tx.timeStamp
                    };
                }
                if (usdtIn > 0 && tokenOut > 0) {
                    return {
                        hash: tx.hash,
                        usdtAmount: usdtIn,
                        tokenAmount: -tokenOut,
                        tokenAddress,
                        isBuy: false,
                        isSell: true,
                        timestamp: tx.timeStamp
                    };
                }
                return null;
            }

            function groupByHash(transfers) {
                const map = {};
                for (const tx of transfers) {
                    if (!map[tx.hash]) map[tx.hash] = [];
                    map[tx.hash].push(tx);
                }
                return Object.values(map);
            }

            function analyzeUSDTTrades(address, groupedTxs, timeRange) {
                const trades = [];
                let totalBuy = 0, totalSell = 0;
                for (const txGroup of groupedTxs) {
                    // å–æ¶ˆè·¯ç”±è¿‡æ»¤
                    // const isSwap = txGroup.some(tx =>
                    //     DEX_ROUTER_LIST.includes(tx.to.toLowerCase()) ||
                    //     DEX_ROUTER_LIST.includes(tx.from.toLowerCase())
                    // );
                    // if (!isSwap) continue;

                    // æ—¶é—´è¿‡æ»¤
                    const time = parseInt(txGroup[0].timeStamp);
                    if (time < timeRange.start || time >= timeRange.end) continue;

                    let usdtIn = 0, usdtOut = 0;
                    let hash = txGroup[0].hash;
                    let tokenAddress = txGroup[0].contractAddress;
                    for (const tx of txGroup) {
                        if (tx.to.toLowerCase() === address.toLowerCase()) {
                            usdtIn += parseFloat(tx.value) / 1e18;
                        }
                        if (tx.from.toLowerCase() === address.toLowerCase()) {
                            usdtOut += parseFloat(tx.value) / 1e18;
                        }
                    }
                    if (usdtOut > 0) {
                        trades.push({
                            hash,
                            usdtAmount: -usdtOut,
                            tokenAmount: 0,
                            tokenAddress,
                            isBuy: true,
                            isSell: false,
                            timestamp: time
                        });
                        totalBuy += usdtOut;
                    }
                    if (usdtIn > 0) {
                        trades.push({
                            hash,
                            usdtAmount: usdtIn,
                            tokenAmount: 0,
                            tokenAddress,
                            isBuy: false,
                            isSell: true,
                            timestamp: time
                        });
                        totalSell += usdtIn;
                    }
                }
                return { trades, totalBuy, totalSell };
            }

            // è§£æä¸€ç»„åŒhashçš„USDTè½¬è´¦ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºUSDTä¹°å…¥/å–å‡º
            async function analyzeTxGroup(txGroup, address) {
                const tx = txGroup[0];
                const receipt = await getTxReceipt(tx.hash);
                if (!receipt || !receipt.logs) {
                    console.log(`ã€${address}ã€‘hash:${tx.hash} æ²¡æœ‰æ”¶æ®æˆ–logs`);
                    return null;
                }

                // è·å–ä¸»äº¤æ˜“è¯¦æƒ…
                const txDetail = await getTxDetail(tx.hash);
                if (!txDetail) {
                    console.log(`ã€${address}ã€‘hash:${tx.hash} æ²¡æœ‰ä¸»äº¤æ˜“è¯¦æƒ…`);
                    return null;
                }
                
                const methodId = txDetail.input ? txDetail.input.slice(0, 10).toLowerCase() : '';
                console.log(`äº¤æ˜“ ${tx.hash} æ–¹æ³•ID: ${methodId}`);
                
                // åˆ¤æ–­æ˜¯å¦ä¸ºswapç±»äº¤æ˜“
                const isSwap = (() => {
                    if (!txDetail.input) return false;
                    const input = txDetail.input.slice(0, 10).toLowerCase();
                    // 1inchã€PancakeSwapç­‰swapæ–¹æ³•
                    const swapMethods = [
                        '0xa03de6a9', // 1inch callOneInch
                        '0x7c025200', // 1inch swap
                        '0x84bd6d29', // 1inch clipperSwap
                        '0x12aa3caf', // 1inch swap variant
                        '0xe449022e', // 1inch uniswapV3Swap
                        '0x90411a32', // 1inch swap variant
                        '0xdad12b6c', // 1inch proxySwap
                        '0xe5e8894b', // 1inch proxySwapV2
                        '0x7ff36ab5', // PancakeSwap swapExactETHForTokens
                        '0x38ed1739', // PancakeSwap swapExactTokensForTokens
                        '0x18cbafe5', // PancakeSwap swapExactTokensForETH
                        '0x8803dbee', // PancakeSwap swapTokensForExactTokens
                    ];
                    if (swapMethods.includes(input)) return true;
                    // ç›®æ ‡åœ°å€æ˜¯DEXè·¯ç”±
                    if (DEX_ROUTER_LIST.includes(tx.to.toLowerCase())) return true;
                    return false;
                })();

                // å³ä½¿ä¸æ˜¯swapäº¤æ˜“ï¼Œä¹Ÿå°è¯•åˆ†æUSDTè½¬è´¦
                // è¿™èƒ½ç¡®ä¿æ•è·æ‰€æœ‰ç±»å‹çš„USDTäº¤æ˜“

                // è®¡ç®—gasè´¹ç”¨
                const gasUsed = parseInt(receipt.gasUsed, 16);
                const gasPrice = parseInt(txDetail.gasPrice, 16);
                const gasCost = gasUsed * gasPrice / 1e18;

                const ERC20_TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                let usdtIn = 0, usdtOut = 0, tokenIn = 0, tokenOut = 0, tokenAddress = '';

                // ç‰¹åˆ«å¤„ç†1inchäº¤æ˜“
                const is1inch = ['0xdad12b6c', '0xe5e8894b', '0xa03de6a9'].includes(methodId);
                if (is1inch) {
                    console.log(`å¤„ç†1inchäº¤æ˜“: ${tx.hash} (æ–¹æ³•: ${methodId}), æ¥è‡ª: ${tx.from.toLowerCase()}, ç›®æ ‡: ${tx.to.toLowerCase()}`);
                    
                    // ä»”ç»†æ£€æŸ¥1inchäº¤æ˜“çš„æ—¥å¿—
                    for (const log of receipt.logs) {
                        if (log.topics[0] === ERC20_TRANSFER_TOPIC) {
                            const contract = log.address.toLowerCase();
                            const from = '0x' + log.topics[1].slice(26).toLowerCase();
                            const to = '0x' + log.topics[2].slice(26).toLowerCase();
                            let amount = 0;
                            try {
                                if (log.data && log.data !== "0x") {
                                    amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                                }
                            } catch (e) {
                                amount = 0;
                            }
                            
                            console.log(`1inchæ—¥å¿—: åˆçº¦=${contract}, ä»=${from}, åˆ°=${to}, é‡‘é¢=${amount}, ç”¨æˆ·åœ°å€=${address.toLowerCase()}`);
                            
                            // USDTè½¬å‡º - å¯èƒ½æ˜¯ä¹°å…¥çš„ç¬¬ä¸€æ­¥
                            if (contract === USDT_CONTRACT.toLowerCase() && from === address.toLowerCase()) {
                                usdtOut += amount;
                                console.log(`æ£€æµ‹åˆ°USDTæµå‡º: ${amount}`);
                            }
                            
                            // USDTè½¬å…¥ - å¯èƒ½æ˜¯å–å‡ºçš„ç»“æœ
                            if (contract === USDT_CONTRACT.toLowerCase() && to === address.toLowerCase()) {
                                usdtIn += amount;
                                console.log(`æ£€æµ‹åˆ°USDTæµå…¥: ${amount}`);
                            }
                            
                            // éUSDTä»£å¸è½¬å…¥ - å¯èƒ½æ˜¯ä¹°å…¥çš„ç»“æœ
                            if (contract !== USDT_CONTRACT.toLowerCase() && to === address.toLowerCase()) {
                                if (!tokenAddress) tokenAddress = contract;
                                tokenIn += amount;
                                console.log(`æ£€æµ‹åˆ°éUSDTä»£å¸æµå…¥: ${amount}, åˆçº¦: ${contract}`);
                            }
                            
                            // éUSDTä»£å¸è½¬å‡º - å¯èƒ½æ˜¯å–å‡ºçš„å¼€å§‹
                            if (contract !== USDT_CONTRACT.toLowerCase() && from === address.toLowerCase()) {
                                if (!tokenAddress) tokenAddress = contract;
                                tokenOut += amount;
                                console.log(`æ£€æµ‹åˆ°éUSDTä»£å¸æµå‡º: ${amount}, åˆçº¦: ${contract}`);
                            }
                        }
                    }
                    
                    // 1inchç‰¹æ®Šæƒ…å†µ1: proxySwapå¯èƒ½ä¸ç›´æ¥è½¬å…¥ä»£å¸ï¼Œè€Œæ˜¯é€šè¿‡å†…éƒ¨è°ƒç”¨è½¬å…¥
                    if (methodId === '0xdad12b6c' && usdtOut > 0 && tokenIn === 0) {
                        console.log(`proxySwapäº¤æ˜“ ${tx.hash} æ£€æµ‹åˆ°USDTæµå‡ºä½†æ²¡æœ‰ä»£å¸æµå…¥ï¼Œå°è¯•æŸ¥æ‰¾å†…éƒ¨ä»£å¸è½¬è´¦`);
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–éUSDTä»£å¸è½¬å…¥
                        let foundTokenIn = false;
                        for (const log of receipt.logs) {
                            if (log.topics[0] === ERC20_TRANSFER_TOPIC) {
                                const contract = log.address.toLowerCase();
                                const to = '0x' + log.topics[2].slice(26).toLowerCase();
                                
                                // å¦‚æœæœ‰ä»»ä½•éUSDTä»£å¸è½¬å…¥ç”¨æˆ·åœ°å€ï¼Œè§†ä¸ºä¹°å…¥äº¤æ˜“çš„ç›®æ ‡ä»£å¸
                                if (contract !== USDT_CONTRACT.toLowerCase() && to === address.toLowerCase()) {
                                    try {
                                        const amount = parseFloat(BigInt(log.data).toString()) / 1e18;
                                        if (amount > 0) {
                                            console.log(`âœ… proxySwapä¹°å…¥: æ‰¾åˆ°ç›®æ ‡ä»£å¸ ${amount} (åˆçº¦: ${contract})`);
                                            tokenIn = amount;
                                            tokenAddress = contract;
                                            foundTokenIn = true;
                                            break;
                                        }
                                    } catch (e) {
                                        console.error("è§£æä»£å¸æ•°é‡é”™è¯¯:", e);
                                    }
                                }
                            }
                        }
                        
                        // å¦‚æœä»æœªæ‰¾åˆ°ï¼Œå¼ºåˆ¶è¯†åˆ«ä¸ºä¹°å…¥äº¤æ˜“
                        if (!foundTokenIn && usdtOut > 0) {
                            console.log(`âš ï¸ proxySwapå¼ºåˆ¶è¯†åˆ«ä¸ºä¹°å…¥: æ”¯ä»˜ ${usdtOut} USDT`);
                            // å…ˆå°è¯•ä»inputæ•°æ®ä¸­æ‰¾å‡ºç›®æ ‡ä»£å¸åœ°å€
                            try {
                                if (methodId === '0xdad12b6c') { // proxySwap
                                    const toTokenPosition = 202; // proxySwapçš„ç¬¬4ä¸ªå‚æ•°ä½ç½®(toToken)
                                    if (txDetail.input.length >= toTokenPosition + 64) {
                                        const toTokenHex = txDetail.input.substring(toTokenPosition, toTokenPosition + 64);
                                        if (toTokenHex && toTokenHex !== '0000000000000000000000000000000000000000000000000000000000000000') {
                                            // ä»hexä¸­æå–åœ°å€éƒ¨åˆ†
                                            const extractedAddress = '0x' + toTokenHex.substring(24);
                                            console.log(`ä»inputæ•°æ®æå–çš„ç›®æ ‡ä»£å¸åœ°å€: ${extractedAddress}`);
                                            tokenAddress = extractedAddress.toLowerCase();
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error("è§£æinputæ•°æ®é”™è¯¯:", e);
                            }
                            
                            // æ— è®ºå¦‚ä½•éƒ½è®°å½•ä¸ºä¹°å…¥äº¤æ˜“
                            return {
                                hash: tx.hash,
                                usdtAmount: -usdtOut,
                                tokenAmount: tokenIn > 0 ? tokenIn : 1, // å¦‚æœæ²¡æ‰¾åˆ°å…·ä½“æ•°é‡ï¼Œé»˜è®¤ä¸º1
                                tokenAddress: tokenAddress || "æœªçŸ¥ä»£å¸", // å¦‚æœæ²¡æ‰¾åˆ°ä»£å¸åœ°å€ï¼Œæ ‡è®°ä¸ºæœªçŸ¥
                                isBuy: true,
                                isSell: false,
                                timestamp: tx.timeStamp,
                                gasCost: gasCost,
                                note: "è‡ªåŠ¨è¯†åˆ«çš„1inchä¹°å…¥äº¤æ˜“"
                            };
                        }
                    }
                    
                    // 1inchç‰¹æ®Šæƒ…å†µ2: å¤„ç†å…¶ä»–1inchæ–¹æ³•çš„ä¹°å…¥
                    if (is1inch && usdtOut > 0 && tokenIn === 0) {
                        console.log(`1inchäº¤æ˜“ ${tx.hash} (${methodId}) æ£€æµ‹åˆ°USDTæµå‡ºä½†æ²¡æœ‰ä»£å¸æµå…¥ï¼Œå¼ºåˆ¶è¯†åˆ«ä¸ºä¹°å…¥äº¤æ˜“`);
                        
                        return {
                            hash: tx.hash,
                            usdtAmount: -usdtOut,
                            tokenAmount: 1, // é»˜è®¤æ•°é‡
                            tokenAddress: tokenAddress || "æœªçŸ¥ä»£å¸",
                            isBuy: true,
                            isSell: false,
                            timestamp: tx.timeStamp,
                            gasCost: gasCost,
                            note: "è‡ªåŠ¨è¯†åˆ«çš„1inchä¹°å…¥äº¤æ˜“"
                        };
                    }
                }

                // ä¸“é—¨æ£€æµ‹BaseSwapRouter + callOneInchç»„åˆ
                if (methodId === '0xa03de6a9' && tx.to.toLowerCase() === '0xb300000b72deaeb607a12d5f54773d1c19c7028d'.toLowerCase()) {
                    console.log(`æ£€æµ‹åˆ°ç‰¹æ®Šç»„åˆ: callOneInch + BaseSwapRouter, äº¤æ˜“: ${tx.hash}`);
                    
                    // å¼ºåˆ¶è®¾ç½®dexä¸ºBaseSwapRouter
                    dex = 'BaseSwapRouter';
                    
                    // æ·»åŠ ç‰¹æ®Šå¤„ç†é€»è¾‘ï¼Œç¡®ä¿æ­£ç¡®è¯†åˆ«æ˜¯å¦ä¸ºå–å‡ºäº¤æ˜“
                    // ...ä¸ç°æœ‰çš„å†…éƒ¨äº¤æ˜“æ£€æµ‹é€»è¾‘ç±»ä¼¼...
                }

                // é€šç”¨æ£€æŸ¥ - å¿…é¡»æ”¾åœ¨1inchç‰¹æ®Šå¤„ç†å
                if (usdtOut > 0 && tokenIn > 0) {
                    console.log(`âœ… æ£€æµ‹åˆ°ä¹°å…¥äº¤æ˜“ ${tx.hash}: æ”¯ä»˜${usdtOut} USDT, è·å¾—${tokenIn}ä»£å¸`);
                    return {
                        hash: tx.hash,
                        usdtAmount: -usdtOut,
                        tokenAmount: tokenIn,
                        tokenAddress,
                        isBuy: true,
                        isSell: false,
                        timestamp: tx.timeStamp,
                        gasCost: gasCost
                    };
                }
                
                // æ£€æµ‹å–å‡ºäº¤æ˜“
                if (usdtIn > 0 && tokenOut > 0) {
                    console.log(`âœ… æ£€æµ‹åˆ°å–å‡ºäº¤æ˜“ ${tx.hash}: æ”¯ä»˜${tokenOut}ä»£å¸, è·å¾—${usdtIn} USDT`);
                    return {
                        hash: tx.hash,
                        usdtAmount: usdtIn,
                        tokenAmount: -tokenOut,
                        tokenAddress,
                        isBuy: false,
                        isSell: true,
                        timestamp: tx.timeStamp,
                        gasCost: gasCost
                    };
                }
                
                return null;
            }

            async function getBNBPrice() {
                try {
                    const res = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT');
                    const data = await res.json();
                    return parseFloat(data.price);
                } catch (e) {
                    return 0;
                }
            }
        });
    </script>
</body>
</html>
